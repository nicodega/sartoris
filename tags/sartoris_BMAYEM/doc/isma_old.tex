\documentclass[11pt, letterpaper, twoside, english]{book}

%\topmargin  0.25in
%\headheight 0.2in
%\headsep    0.3in
%\textheight 8.5in
%\textwidth  6.0in
%\footskip   0.7in

\setlength{\parskip}{1.5ex}


\usepackage[activeacute]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsfonts, amssymb}
\pagestyle{plain}

\begin{document}
\frontmatter
\thispagestyle{empty}

\vspace*{2.5cm}
\noindent\makebox{\begin{minipage}{\textwidth}{
\flushright \Huge Introduction to the \\
Sartoris Microkernel Architecture

}

\noindent\rule{\textwidth}{4pt}

\noindent\flushright { \large Design concepts and implementation notes for the x86 platform. }

\end{minipage}
}

\vspace{10cm}
\noindent\makebox{\begin{minipage}{\textwidth}{
\flushright by Santiago Bazerque and Nicol\'as de Galarreta \\[1.5ex]
for Sartoris version 0.5, \today.

}
\end{minipage}
}

\newpage
\thispagestyle{empty}
\cleardoublepage

\chapter{Abstract}

The modularization of the software design process has become a mainstream tool in the struggle to build large, reliable programs. The efficiency constraints that this practice imposes makes the (already cumbersome by itself) task of creating operative systems that are rightfully modularized a fascinating one.

The Sartoris project's goal is to develop a portable microkernel that provides a simple processor abstraction, yet a powerful enough one to support a full featured operative system. Therefore, boot primitives and system calls to perform crude process creation, (shared) memory management and asynchronous message-passing are the only features directly supported by the kernel. The rest of the functionality of the operative system, namely cpu schedulers, filesystems,  device drivers, \ldots{} are to be implemented in user space.


\tableofcontents

\mainmatter

\chapter{Microkernel design}

\section{General considerations}
Any operating system designed to run modern hardware must overcome the (rather complicated) details of the management of the central processors and their memory management units. In most processor architectures, this implies using specific machine instructions and mantaining a set of data structures in memory from which the hardware can obtain the current state of the system. Furthermore, the handling of interrupt requests is in itself a nontrivial task, and it increases the overall complexity of the system. Programming interrupt handlers might be bug-prone and problematic.

Therefore, it seems reasonable to encapsulate the routines that interact directly with the processor, and that is what the Sartoris microkernel is intended to do. Moreover, in order to provide a suitable abstraction to the operating system, the microkernel does not need to provide many other functions. The system calls provided by Sartoris can be grouped as follows:\footnote{Every processor architecture has unique features that must be handled in the kernel (i.e. perfomance monitoring hardware). However, a single system call will provide the necessary cpu dependent functions. }

\begin{enumerate}
\item[]\textbf{Task and thread management.} These system calls cover the loading and unloading of tasks into the system, and the creation and destruction of threads. Under Sartoris, an interrupt handler is just a special thread, that is invoked every time the corresponding interrupt request line is raised.
\item[]\textbf{Memory management.} This subsystem should provide an abstraction of the paging mechanism, but Sartoris doesn't support paging in the current implementation (version 0.5), in which a pure segmented memory organization is used. Also, the sharing of memory between tasks is possible through the system calls that manage Sartoris' Shared Memory Objects\footnote{The memory-sharing functionality of the kernel is necessary until paging is supported, hopefully in Sartoris version 1.0.}.
\item[]\textbf{Message passing.} The kernel provides an asynchronous messaging sytem, in the form of a set of ports assigned to each task. Each port functions as a mailbox where fixed-sized messages from other tasks are received.
\end{enumerate}

\noindent{}Before each of the subsystems is further described, the main issues considered in the design will be reviewed:
\begin{enumerate}
\item[] The microkernel should present a simple yet effective abstraction of the processor to the operative system. The services offered by the microkernel should be clearly defined and easy to understand.
\item[] In order to obtain effective portability, a suitable interface that encapsulates the architecture-dependent sections of the kernel code has to be defined.
\item[] Kernel services should be provided in a policy-independent way, whenever this is possible. The design of the operative system should not be over-restricted by the underlying microkernel architechture.
\item[] The design of the microkernel should allow an efficient implementation of the most common operative system functions, considering the inherent constraints that the microkernel architecture imposes to the system.
\end{enumerate}

\section{Introduction and sources organization}
A kernel might be defined as the set of functions that it implements. The full Sartoris system call set is declared in the file \textsf{include/sartoris/sycall.h}:

\begin{sf}
\noindent /* sartoris system calls */ \\
\\
\#ifndef SYSCALL \\ 
\#define SYSCALL \\
\\
\#include $<$sartoris/kernel.h$>$ \\
\\
/* multitasking */ \\
int create\_task(int address, struct task *tsk, int *src); \\
int destroy\_task(int task\_num); \\
\\
/* threading */ \\
int create\_thread(int id, struct thread *thr); \\
int destroy\_thread(int id); \\
int run\_thread(int id); \\
\\
/* message-passing */ \\
int send\_msg(int to\_address, int port, void *msg); \\
int get\_msg(int port, void *msg, int *id); \\
int get\_msg\_count(int port); \\
\\
/* memory sharing */ \\
int share\_mem(int target\_task, void *addr, int size, int perms); \\
int claim\_mem(int smo\_id); \\
int read\_mem(int smo\_id, int off, int size, void *dest); \\
int write\_mem(int smo\_id, int off, int size, void *src); \\ 
int pass\_mem(int smo\_id, int target\_task); \\
\\
\#endif \\ \\
\end{sf}
The architecture-independent part of the system calls implementation is contained in the file \textsf{mk/kernel.c}. The algorithms that handle the kernel high level data structures are implemented in the rest of the files of the \textsf{mk/} directory. The object file obtained from this sources has to be linked with the implementation of the low level functions for the target processor, which should be  \textsf{arch/target/kernel/cpu-arch.o}, where \textsf{target} is a symlink to the desired architecture. Of course, the set of unix makefiles provided with the sources takes care of the hole compile and link cycle.  The low-level interface is described in section \ref{sec:lowlevelinterface}. 

\section{Tasks and threads}
All the processing (even interrupt handling!) in a Sartoris based system is done in the context of a task, and a thread within that task. A task is loaded into memory upon it's creation, and remains in main memory until it is terminated. No swapping of tasks is supported.

A task is composed by a flat virtual address space and communication mechanisms (ports and shared memory objects) and is identified by a number between zero and \textsf{MAX\_TSK}\footnote{A constant defined by the implementation}, which is the parameter \textsf{address} passed to the system call \textsf{create\_task(int address, struct task *tsk, int *src)}, where \textsf{*src} points to the beginning of the task image within the calling task's address space, and \verb|*tsk| points to a structure of the type \\
\\
\begin{sf}
\noindent struct task \{ \\
\indent  int mem\_adr; \\
\indent  int size; \\
\indent  int type; \\
\indent  int thread\_count; \\
\}; \\
\end{sf}
\\
\noindent where \textsf{mem\_adr} indicates the physical address where this task should be placed in main memory\footnote{The organization of the tasks in physical memory is therefore under absolute control of the operative system.}, \textsf{size} indicates the size (in words) of the task being created, and \textsf{type} is one of the following:
\begin{enumerate}
\item[] \textsf{SRV\_TSK}: Service tasks have access to all the Sartoris system calls, and can perform input-output operations. In general, service tasks are used to implement operative system services.
\item[] \textsf{PRC\_TSK}: Process tasks can access only the memory-sharing and message-passing system calls, and don't have input-output privileges. User programs should run as process tasks.
\end{enumerate}
The variable \textsf{thread\_count} is used internally by the kernel and it's initial value is ignored.
Tasks are destroyed using the similar function \textsf{destroy\_task}, which receives the address of the task being destroyed.

\textbf{kernel internals:} enough space is reserved statically to hold the \textsf{task} data structure of the \textsf{MAX\_TSK} tasks that can be loaded into the system in the array \textsf{tasks}, and the \textsf{address} that was passed to the system call is used to index the \verb|tasks| array. The details are defined in the file \textsf{include/sartoris/kernel.h}.

A thread is a path of execution within a given task. The maximum amount of concurrent threads is determined by the constant \textsf{MAX\_THR}. A task might have zero, one, or more threads. Threads are created using the system call \textsf{create\_thread(int id, struct thread *thr)}. The parameter \textsf{id} is an integer that uniquely identifies each thread, and must not exceed \textsf{MAX\_THR}-1. The structure \textsf{thread} is defined as \\
\\
\begin{sf} \noindent struct thread \{ \\
\indent  int task\_num; \\
\indent  int type; \\
\indent  int irq; \\
\indent  int priv\_level; \\
\indent  int ep; \\
\indent  int stack; \\
\}; \\
\end{sf}
\\
where \textsf{task\_num} is the task that defines the context in wich this thread is to be created, and type is one of the following:
\begin{enumerate}
\item[] \textsf{RUNNABLE}: Regular threads, that can be started or resumed using the \textsf{run\_thread} system call.
\item[] \textsf{IRQ\_HANDLER}: Interrupt handler threads are used to serve normal interrupts. They provide the necessary mechanisms to interrupt the currently running thread and resume it's execution as soon as the pending interrupt has been serviced. Exceptions and traps usually may be handled using interrupt handlers.
\item[] \textsf{IRQ\_DRIVEN}: Interrupt driven threads are launched in response to an interrupt request, but are started in a way analogous to the \textsf{run\_thread} system call, no immediate resuming of the interrupted thread is supported. An interrupt-driven scheduler thread illustrates the need for this thread flavour.
\end{enumerate}
The \textsf{irq} field indicates de interrupt that should start this thread (if it is not of type \textsf{RUNNABLE}), and \textsf{priv\_level} indicates from which privilege levels can that interrupt be generated by software. The field \textsf{ep} indicates the offset of the program's entry point, and \textsf{stack} is the address of it's user-level stack.

Threads are destroyed using the \textsf{|destroy\_thread} system call\footnote{It may be worth noting that the currently running thread can't destroy itself.}, and may be started (or resumed) by interrupt requests signaled to the processor, software generated interrupts, exceptions, traps and the already mentioned \textsf{run\_thread} system call.

\textbf{kernel internals:} each thread's \textsf{id} is used to index the \textsf{threads} statically allocated array, where the \textsf{thread} data structures are stored, in a fashion analogous to the task data. The details are defined in \textsf{include/sartoris/kernel.h}.

\section{Messaging system}
The kernel provides an asynchronous inter-task message system through the \textsf{send\_msg}, \textsf{get\_msg} and \textsf{get\_msg\_count} system calls. The messages have a fixed size defined by the implementation, and the kernel guarantees that messages arrive in FIFO order, but each message queue has a maximum capacity which is also implementation-defined. When a message is sent using the function \textsf{int send\_msg(int to\_address, int port, void *msg)}, the contents of the message pointed by \textsf{msg} are copied to the queue for port number \textsf{port} of task \textsf{to\_address}. The receival of messages is done in an analogous fashion using the function \textsf{int get\_msg(int port, void *msg, int *id)}, which removes the fist message in the supplied \textsf{port}'s queue and copies it's contents to the address \textsf{msg}. The variable \textsf{id} is used to return the id of the sender task. Both functions return 0 on success. 

The function \textsf{int get\_msg\_count(int port)} returns the amount of messages in the queue of the supplied port.

\textbf{kernel internals:} Memory is statically reserved to hold \textsf{MAX\_MSG} messages for each task. Each task has a \textsf{msg\_queue} structure in the array \textsf{msg\_q}. The \textsf{msg\_queue} data structure is defined in the file \textsf{include/sartoris/message.h}. The main data structures are: \\
\\
\begin{sf} \noindent struct port \{ \\
\indent  unsigned int first; \\ 
\indent  unsigned int last; \\
\indent  unsigned int total; \\
\}; \\
\\
struct message \{ \\
\indent  unsigned int sender\_id; \\
\indent  unsigned int data[MSG\_LEN]; \\
\indent  unsigned int next; \\
\}; \\
\\
struct msg\_queue \{ \\
\indent  struct port ports[PORTS]; \\
\indent  struct message messages[MAX\_MSG]; \\
\indent  unsigned int free\_first; \\
\}; \\
\end{sf}
\\
Each port is a linked list in the \textsf{messages} array of messages of a given task; the \textsf{first} and \textsf{last} members of the \textsf{port} data structure point to the first and last messages being held in \textsf{port}. A linked list that joins all the currently unused messages in the array is also mantained. Therefore messages can be send and received in constant time. The functions \textsf{init\_queue}, \textsf{enqueue} and \textsf{dequeue} are implemented in \textsf{mk/message.c}.

\section{Memory management}
As paging is still unsupported in this version, the microkernel must supply a mechanism to perform memory sharing, which otherwise would be done through the use of shared pages. Therefore, the kernel manages a set of Shared Memory Objects for each task wich allow other tasks to access it's address space in a controlled way. However, there is no memory aliasing, and access is limited to reading from and writing to the shared sections using system calls that copy memory contents from one task address space to another. 

The system call \textsf{int share\_mem(int target\_task, void *addr, int size, int perms)} creates a SMO of size \textsf{size} words\footnote{The actual unit in which size is expressed is defined by the implementation.} at offset \textsf{addr} of the current task's address space, that can be accessed by the task\footnote{What is meant here is that it can be accessed by any thread of the corresponding task.} \textsf{target\_task}. The parameter \textsf{perms} indicates if access is granted for reading, writing, or both. The function returns an id number that identifies the SMO just created, or -1 in case of failure. SMOs can be destroyed using the system call \textsf{int claim\_mem(int smo\_id)} and the target task of an SMO can pass it over to another task using the system call \textsf{int pass\_mem(int smo\_id, int target\_task)}, which changes the target task to the supplied parameter.

The system call \textsf{int read\_mem(int smo\_id, int off, int size, void *dest)} copies the \textsf{size} words at offset \textsf{off} of the SMO identified by \textsf{smo\_id} to the address \textsf{dest}. Conversely, the system call \textsf{int write\_mem(int smo\_id, int off, int size, void *src)} copies \textsf{size} words from addres \textsf{src} from the current task's address space to offset \textsf{off} of the SMO identified by \textsf{smo\_id}. Of course, in both cases the current task must be the target task of the SMOs, and have the right permission.

All the memory-sharing system calls excepting \textsf{share\_mem} return 0 in case of success and -1 otherwise.

\textbf{kernel internals:} The data structure \textsf{smo} defines a Shared Memory object within the kernel, which uses a static array to store all the Shared Memory Objects currently in the system, wich is contained in the \textsf{smo\_container} data structure. A linked list of the unused entries is mantained by the kernel, that allows the kernel to create SMOs in constant time. Also, for each active task there is a doubly linked list containing all the SMOs that the task holds, which permits the kernel to free all the SMO entries of a task upon it's destruction in O($n$) time, where $n$ is the number of SMOs in the task.

The data structures are defined int the file \textsf{include/sartoris/shared\_mem.h}: \\
\\
\begin{sf} \noindent struct smo\_container \{ \\
\indent  struct smo smos[MAX\_SMO]; \\ 
\indent  int task\_first\_smo[MAX\_TSK]; \\ 
\indent  int task\_num\_smo[MAX\_TSK]; \\
\indent  int free\_first; \\
\}; \\
\\
struct smo \{ \\
\indent  int base; \\
\indent   int len; \\
\indent   int rights; \\
\indent   int owner; \\
\indent   int target; \\
\indent   int valid; \\
\indent   int next; \\
\indent   int prev; \\
\}; \\
\end{sf}
\\
The memory sharing functions are implemented in \textsf{mk/shared\_mem.c}.

\section{Low-level interface} \label{sec:lowlevelinterface}
The Sartoris microkernel is divided in an architecture neutral section, which is written in C language, and handles the kernel data structures, and an architecture specific section, which handles the processor data structures and it's low level management. The interface that defines the low-level functions is located in \textsf{include/saroris/cpu-arch.h}

\begin{sf} \noindent /* This are the arch-dependent functions needed to support the kernel */ \\
\\
\#ifndef CPUARCH \\
\#define CPUARCH \\
\\
\#include $<$sartoris/kernel.h$>$ \\
\\
void arch\_init\_cpu(void); \\
\\
int arch\_create\_task(int task\_num, struct task* tsk); \\
int arch\_destroy\_task(int task\_num); \\
int arch\_create\_thread(int id, struct thread* thr); \\
int arch\_destroy\_thread(int id, struct thread* thr); \\
int arch\_run\_thread(int id); \\
void arch\_mem\_cpy(int* src, int* dst, int l); \\
\\
void arch\_dump\_cpu(void); \\
\\
int arch\_cli(void); \\
void arch\_sti(int); \\
\\
\#endif \\
\end{sf}
\\
The architecture specific functions are called from the proper system calls. While they may access the rest of the kernel's data, they should define their own architecture specific data structures and reserve the necessary memory regions to hold them. 

\chapter{The x86 implementation}

\section{System organization overview}
Initializing the processor and loading the microkernel and the init-process to main memory is the very fist task that the IA32 specific section of Sartoris must overcome. Once the bootstrapping has concluded, the kernel initialization function must create the system tables and execute the init task, which will start the operative system. 

The main purpose of the architecture specific functions in Sartoris version 0.5 is the management of tasks and threads. Paging, wich is another area where architecture specific handling will be necessary, is still unsupported. In the IA32 architecture, the creation and destruction of tasks under a pure segmented memory model requires updating the descriptors in the Global Descriptor Table and one Local Desciptor Table, so that the user segments have the correct privlege levels and point to the task's memory areas. To perform the multiplexing of the CPU into several threads, the IA32 architecture defines a data structure wich contains all the information required to create, suspend and resume a thread, the Task State Segment.

The IA32 kernel code is located in \textsf{arch/i386/kernel/}.

\section{Bootstrapping}

In the PC architecture, bootstrapping begins after the BIOS loads the first 512-byte sector of the boot drive to offset 0x7c00, and executes it in real mode. The boot sector assembly source is in \textsf{arch/i386/boot/boot.s}. It uses BIOS function 0x13 to load the raw area immediately following the boot sector in the boot media to memory, extracting the kernel image and the init task image. Then it jumps to the kernel initialization routines. The boot media and the kernel size are hardcoded in the boot sector for now, so they have to be manually set.

In order to run the kernel, the boot sector must also enable the 20'th address line in the bus, which is done through the keyboard controller and change the processor executing mode to protected mode. Temporary IDT and GDT tables are set up before the switch to protected mode.

\section{IA32 system tables}

\subsection{Global Descriptor Table}  \label{subsec:GDT}

The GDT contains the descriptors that are shared among all the tasks in the system. Some descriptors, in particular the LDT descriptors used for tasking and the TSS descriptors used for threading, must reside in the GDT. Some other descriptors that are shared among all the tasks are also in the GDT. The variables \textsf{MAX\_SCA}, \textsf{MAX\_TSK} and \textsf{MAX\_THR} are used to statically reserve entries in the GDT for the maximum possible amount of system calls, tasks and threads. The descriptor layout in the GDT is: \\
\\

\begin{tabular}{|l|l|l|}
\hline
\textbf{descriptor group} & \textbf{how many?} & \textbf{details} \\
\hline
system descriptors & 4 & dummy, kernel code, \\
 & & kernel data, high memory area \\
\hline
syscalls & \textsf{MAX\_SCA} & call gates for the system calls \\
\hline
LDT descriptors & \textsf{MAX\_TSK} & descrptors for task's \\
 & & Local Descriptor Tables \\
\hline
TSS descriptors & \textsf{MAX\_THR} & descriptors for thread's \\
 & & Task State Segments \\
\hline 
\end{tabular}
\\
\\

The very first descriptor of the GDT is a null descriptor, required by the processor architecture\footnote{Loading a zero offset into an unused segment selector register is licit if the corresponding descriptor is null; a protection fault is only generated if a memory access through the null descriptor is attempted.}. The kernel sees the memory as a flat address space. The second descriptor is the kernel code descriptor, which defines a 32 bits execute-read segment with base zero and limit set to 16 megabytes (this is all the maximum amount of memory currently supported), and Descriptor Privlege Level set to zero (most privileged). The third descriptor is the kernel data descriptor, like the second one but with data-read-write type. The fourth descriptor is has a Descriptor Privilege Level of two, and is a data-read-write type descriptor which gives the service level tasks access to the high memory area\footnote{region between the physical addresses 0xa0000 and 0x100000.}, since numerous input output devices are configured to use buffers in this area (ie the standard VGA adapter). The next \textsf{MAX\_SCA} entries are reserved for the system calls' call gates. A call gate allows the microkernel to offer it's services in a controlled way. Each gate has a privilege level (some calls may be accessed from service tasks only), an entry point into the kernel code, and a parameter count. When a thread performs a far call to one of these gates, control is transfered to the kernel and the right amount of parameters are copied to the kernel privilege zero stack. The following descriptors are used to hold the LDTs and the TSS, which will be discussed later in this section. 

\subsection{Interrupt Descriptor Table}

The Interrupt Descriptor Table contains the descriptors that define the processor's reaction to exceptions and external or software generated interrupt. The first 32 entries are reserved for the processor's exceptions, while the rest may be used to handle external interrupts or operative system services invoked through an \textsf{int} instruction. The action taken to add an exception or interrupt handler depends on the type of the thread being created. If it is an \textsf{IRQ\_HDL} thread, a task gate is located in the given offset of the IDT. When this interrupt handler is executed, a task switch is automatically initiated by the processor and the back link field of the handler's task points to the interrupted task's TSS, which is marked busy. The handler must return to the interrupted procedure with an \textsf{iret} instruction, which will initiate a task switch to the interrupted thread. If the thread being created is an \textsf{IRQ\_DRV} thread, the number of the thread is stored and it is used to execute a \textsf{run\_thread} system call each time this interrupt is to be serviced. There is no nesting of tasks.

\subsection{Local Descriptor Tables}

Each LDT must be contained in a special system segment in the GDT. Every task has it's own linear address defined by two descriptors in it's Local Descriptor Table: an execute-read type descriptor for it's code and a read-write descriptor for it's data and stacks.

\section{IA32 function implementation details}

This section describes the behavior of the IA32 implementation of the architecture dependent functions.

\textsf{arch\_init\_cpu}: 
\begin{enumerate}
\item[]\textbf{PIC reprogramming.} The init functions reprograms the progammable interrupt controllers so that the interrupts from the master controller go to the offsets 32-39 and interrupts from the slave controller go to offsets 40-47 of the IDT. The slave PIC is cascaded through the second interrupt request line of the master. All the interrupts are disabled though the PICs interrupt masks.
\item[]\textbf{GDT set up.} The dummy, kernel code, kernel data and high memory area descriptors of the GDT are created. All the other descriptors are invalidated. The Global Descriptor Table is loaded using the \textsf{lgdt} instruction, which using a virtual descriptor composed by a linear base and a limit located in main memory loads the GDTR register.
\item[]\textbf{syscall hooking.} All the task gates for the system calls are created in the corresponding GDT positions. This is done through the \textsf{hook\_syscall} function, with the correct entry point, privilege level and parameter count for each call, as described in subsection \ref{subsec:GDT}.
\item[]\textbf{IDT set up.} The fist 32 entries of the IDT are filled with interrupt gates\footnote{An interrupt gate is very similar to a call gate, but the processor handles the interrupt enable flag differently.} that point to routines that will dump the cpu registers and information about the currently running task and thread and halt the machine. These handlers should be replaced by the operative system exception handling threads, but for operative system development and to show some diagnostic in case the operative system dies very early in the boot process these default handlers are useful. The rest of the IDT is full with invalid descriptors. Finally, the IDT is loaded in a way analogous to the GDT, using the \textsf{lidt} instruction.
\item[]\textbf{Init service execution} Now the cpu is ready to run the microkernel. Using the \textsf{create\_task} and \textsf{create\_thread} system calls, the operative system init service is created in the exact address to which it was fetched earlier by the bootstrapping code (currently, at the three megabyte mark), and executes using the \textsf{reun\_thread} system call. This is the last action the microkernel will take on it's own initiative.
\end{enumerate}

\textsf{arch\_create\_task}: 
\begin{enumerate}
\item[]\textbf{LDT set up.} An execute-read segmet and a read-write segment are created in the task's local descriptor table first and second descriptors, with the privilege level corresponding to the task being created and base and limit acording to the corresponding syscall parameters.
\item[]\textbf{create LDT descriptor.} The GDT descriptor for this LDT is created with the correct privilege level.
\end{enumerate}

\textsf{arch\_destroy\_task}: 
\begin{enumerate}
\item[]\textbf{invalidate LDT descriptor.} The task's LDT descriptor is invalidated, preventing any future access to or execution from the task's address space.
\end{enumerate}

\textsf{arch\_create\_thread}: 
\begin{enumerate}
\item[]\textbf{TSS set up.} The Task State Segment holds the contents of all the general purpose registers, the base and stack registers for all the privilege levels, the segment selector registers, the eflags register, the LDT selector register, the instruction pointer register, and a few more that are not used under Sartoris version 0.5. In a new thread's TSS, all the general purpose registers are set to zero. The base and stack pointer for the thread's privilege level are set to the stack value supplied by the call, while the privilege zero base and stack pointer are set to the kernel assigned stack. The unused base and stack registers are set to zero. The cs register is loaded with a selector for the code segment in the task's LDT with the correct Requested Privilege Level, while cs, ds and ss are loaded with the second descriptor in the LDT, the data segment. The ss0 register is loaded with the kernel data segment. The fs and gs registers are loaded with null descriptors, but in service task's threads fs is loaded with a selector for the high memory area descriptor located in the fourth entry of the GDT. The eflags register is loaded with IO Privilege set to 2 (only service tasks can access the IO space), and interrupts disabled iff this is an interrupt handling thread. The LDT selector register is loaded with the task's LDT selector. Finally, the instruction pointer register is loaded with the entry point supplied for the newly created thread.
\item[]\textbf{create TSS descriptor.} Once the TSS is in place, a descriptor in the GDT must be created through wich the thread may be started and resumed.
\item[]\textbf{update IDT.} If the thread is of type \textsf{IRQ\_HDL}, the IDT position for the requested interrupt line or exception must be updated, with a task gate that points to the thread's TSS. If the thread is of type \textsf{IRQ\_DRV}, an interrupt gate that points to a special section of the kernel is created, and the number for the thread is saved in an array. Later on, when this interrupt is handled, this special section of the kernel will fetch the thread number and initiate a task switch. 
\item[]\textbf{update interrupt mask.} The interrupt request line must be enabled in the corresponding PIC if this is an external interrupt.
\end{enumerate}

\textsf{arch\_run\_thread}: 
\begin{enumerate}
\item[]\textbf{do task switch.} A task switch to the target thread is initiated by performing a far jump to offset zero of the thread's TSS descriptor in the IDT. No nesting of tasks is produced.
\end{enumerate}

\textsf{arch\_cli}:
\begin{enumerate}
\item[]\textbf{disable interrupts.} The interrupt enable bit of the eflags register is saved and then cleared. The function returns the original value.
\end{enumerate}

\textsf{arch\_sti}:
\begin{enumerate}
\item[]\textbf{enable interrupts.} The previous value of the interrupt enable bit is examined and interrupts are re-enabled only if they weren't disabled before the call to the previous \textsf{arch\_cli}.
\end{enumerate}

\chapter{A simple example: Oblivion}

\section{Introduction}

Even though Sartoris should be able to support a full operative system in it's present state, the copy-based mechanism used to share memory imposes severe performance constraints on the inter-task communication mechanisms. The lack of paging is another reason for delaying the implementation of a more serious operative system until Sartoris has evolved over it's initial release. Oblivion is a simple operative system that runs on top of Sartoris 0.5, more as a sophisticated testing tool both for the implementation and the design of the microkernel than as a practical operative system. It is composed by a process management service, a console service, a ram-filesystem service, a floppy-filesystem service and a DMA-floppy access service. Oblivion's user interface is composed by a small shell embedded into the process manager. It supports virtual consoles, which allow multiple simulaneus users, a simple read-only ram-filesystem where system programs are located, a simple floppy drive filesystem where more general files may be permanently stored, and the loading and execution of user programs from the shell. Even though it's main purpose is testing the microkernel, some of the components have a modular design, and more complete operative systems based on future versions of Sartoris should be able to use all the drivers, the service that supports the virtual consoles and the basics of the process manager. 

Oblivion implementation is located in the directory \textsf{arch/i386/os/oblivion/}.

\section{Oblivion overview}

As was stated later, the initialization of the operative system under Sartoris is performed by a task that is loaded to memory and executed by the microkernel. Oblivion's init task contains the images of all the operative system's service tasks, and it loads them using the function \textsf{create\_task} and creates their main threads, including the process manager main thread, which is chained to the timer interrupt and will become the system's scheduler thread. The memory images of the operative system services are located at a fixed offset in the init task's address space, leaving enough space for the code and data of the init service itself at the beginnig of it's memory space. The images are organized in fixed size equal regions of memory, making the loading simple. The task and thread numbers for the operative system services are statically defined in the file \textsf{include/oblivion/layout.h}. Once the loading and the creation of threads are done, the init service will enable external interrupts and wait idle until the scheduler is invoked for the first time.

The scheduler uses a simple round robin scheduling algorithm, without any priorities. The operative system's threads and user space threads get the same privilege. There is no blocking of threads, when a user program makes a request and must wait for an event (for example, the completition of an IO operation), it may neglect it's cpu time slice by re-invoking the scheduler thread as soon as it has checked that the acknowledge it is waiting for has not arrived. Every operative system service finishes it's own initialization the first time it is invoked. Extra interrupt handlers are created and devices are initialzed at that stage.

The scheduler handles the commands received from the shell and the loading of user programs. Each virtual console can run exactly one user program at a time. When a command arrives, the ram-filesystem is queried first by the scheduler to check if it contains a file whose name maches the command received. If there is no such a file (the ram-fs returns a ``file-not-found'' error), the request is forwarded to the floppy filesystem. If a program is located in any of the above filesystems, it is loaded to a buffer in the process manager's address space through a shared memory object and a task and a thread are created using the microkernel services.

The default exception handlers set up by the microkernel are not overriden, and therefore any error will provoke the dumping of the cpu-state and bring the machine to a halt. It would be simple to attach threads from the process manager task to the most common exceptions (like the general protection fault) to protect the operative system from misbehaving user programs.

The filesystems don't support a directory structure, they just partition the physical media in fixed sized slots and assign filenames to them. There are system programs to mount and umount the floppy drive in the ram-fs, as well as a simple ``ls'' program that lists the contents of the floppy currently mounted, if any. The floppy filesystem supports the ``create file'', `delete file'' and ``format'' operations. The ``format'' command just writes an empty filesystem superblock to the floppy, but the driver supports low level formatting that could be enabled in a future version.

\chapter{Final thoughts}

We consider that the microkernel concept provides a natural and adequate layer of abstraction between the management of the central processor, the memory management unit and the interrupt controller and the rest of the operative system. Sartoris, being  a very thin microkernel (even the scheduling is performed outside the kernel), imposes a few performance constraints on the operative system; up to what extent they can be removed is something we expect to determine in future versions. It is clear however from the Oblivion experience that Sartoris is mature enough to support the basic operative system functions.

On the implementation front, some features of the IA32 architecture, like processor hardware support for threading using Task State Segments, interrupt handling threads through task gates in the IDT, thread-nesting support through TSS nesting, and call gates to provide controlled access to operative system services, really simplified the implementation of the microkernel. The suspension and re-activation of threads is reduced to the execution single machine instruction.

The path to Sartoris version 1.0 goes through, at least, the inclusion of paging support in the microkernel, which should render the Shared Memory Objects obsolete and allow the use of memory aliasing as a tool for faster inter-task communications mechanisms, and the desing of a more robust interrupt handling system, probably using a software stack to nest interrupts.

As the microkernel evolves, it is our intention to continue developing an operative system, perhaps transforming Oblivion into something useful someday in the future.
\end{document}

