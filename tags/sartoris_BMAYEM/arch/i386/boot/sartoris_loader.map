     1                                  
     2                                  ;;
     3                                  ;; This is the kernel loader. This loader is multiboot conforming, 
     4                                  ;; meaning it could be loaded either by our Stage 1 or by any Multiboot supporting
     5                                  ;; boot loader like Grub.
     6                                  ;;
     7                                  ;; This stage should leave the kernel at possition 0 on memory and the init image
     8                                  ;; at its defined position.
     9                                  ;;
    10                                  
    11                                  ;; First things first... the multiboot structure
    12                                  ;; is to be placed at the begining of the kernel img.
    13                                  %include "sartoris_multiboot_header.inc"
    14                              <1> 
    15                              <1> %include "multiboot.inc"
    16                              <2> 
    17                              <2> ;;
    18                              <2> ;; Nasm struct definitions for multiboot.
    19                              <2> ;;
    20                              <2> 
    21                              <2> struc multiboot_header
    22 00000000 <res 00000004>      <2> .magic resd 1					;; 0 u32 magic 
    23 00000004 <res 00000004>      <2> .flags resd 1					;; 4 u32 flags
    24 00000008 <res 00000004>      <2> .checksum resd 1				;; 8 u32 checksum  required 
    25 0000000C <res 00000004>      <2> .header_addr resd 1				;; 12 u32 header_addr if flags[16] is set 
    26 00000010 <res 00000004>      <2> .load_addr resd 1				;; 16  u32  load_addr  if flags[16] is set 
    27 00000014 <res 00000004>      <2> .load_end_addr resd 1           ;; 20  u32  load_end_addr  if flags[16] is set 
    28 00000018 <res 00000004>      <2> .bss_end_addr resd 1            ;; 24  u32  bss_end_addr  if flags[16] is set 
    29 0000001C <res 00000004>      <2> .entry_addr resd 1				;; 28  u32  entry_addr  if flags[16] is set 
    30 00000020 <res 00000004>      <2> .mode_type resd 1				;; 32  u32  mode_type  if flags[2] is set 
    31 00000024 <res 00000004>      <2> .width resd 1					;; 36  u32  width  if flags[2] is set 
    32 00000028 <res 00000004>      <2> .height resd 1					;; 40  u32  height  if flags[2] is set 
    33 0000002C <res 00000004>      <2> .depth resd 1					;; 44  u32  depth  if flags[2] is set 
    34                              <2> endstruc
    35                              <2> 
    36                              <2> %define MULTIBOOTH_MAGIC 0x1BADB002
    37                              <2> %define MULTIBOOTH_FLAG_PAGEALIGN   0x1		;; bit 0 is 1
    38                              <2> %define MULTIBOOTH_FLAG_MEM         0x2		;; bit 1 is 1
    39                              <2> %define MULTIBOOTH_FLAG_VIDEO       0x4		;; bit 3 is 1
    40                              <2> %define MULTIBOOTH_FLAG_ADDRINH     0x20000		;; bit 16 is 1
    41                              <2> 
    42                              <2> ;;	 0       | flags             |    (required)
    43                              <2> ;;           +-------------------+
    44                              <2> ;;   4       | mem_lower         |    (present if flags[0] is set)
    45                              <2> ;;   8       | mem_upper         |    (present if flags[0] is set)
    46                              <2> ;;           +-------------------+
    47                              <2> ;;   12      | boot_device       |    (present if flags[1] is set)
    48                              <2> ;;           +-------------------+
    49                              <2> ;;   16      | cmdline           |    (present if flags[2] is set)
    50                              <2> ;;           +-------------------+
    51                              <2> ;;   20      | mods_count        |    (present if flags[3] is set)
    52                              <2> ;;   24      | mods_addr         |    (present if flags[3] is set)
    53                              <2> ;;           +-------------------+
    54                              <2> ;;   28 - 40 | syms              |    (present if flags[4] or
    55                              <2> ;;           |                   |                flags[5] is set)
    56                              <2> ;;           +-------------------+
    57                              <2> ;;   44      | mmap_length       |    (present if flags[6] is set)
    58                              <2> ;;   48      | mmap_addr         |    (present if flags[6] is set)
    59                              <2> ;;           +-------------------+
    60                              <2> ;;   52      | drives_length     |    (present if flags[7] is set)
    61                              <2> ;;   56      | drives_addr       |    (present if flags[7] is set)
    62                              <2> ;;           +-------------------+
    63                              <2> ;;   60      | config_table      |    (present if flags[8] is set)
    64                              <2> ;;           +-------------------+
    65                              <2> ;;   64      | boot_loader_name  |    (present if flags[9] is set)
    66                              <2> ;;           +-------------------+
    67                              <2> ;;   68      | apm_table         |    (present if flags[10] is set)
    68                              <2> ;;           +-------------------+
    69                              <2> ;;   72      | vbe_control_info  |    (present if flags[11] is set)
    70                              <2> ;;   76      | vbe_mode_info     |
    71                              <2> ;;   80      | vbe_mode          |
    72                              <2> ;;   82      | vbe_interface_seg |
    73                              <2> ;;   84      | vbe_interface_off |
    74                              <2> ;;   86      | vbe_interface_len |
    75                              <2> 
    76                              <2> %define MBOOTINFO_FLAGMEM 0x1
    77                              <2> %define MBOOTINFO_FLAGMMAP 0x40
    78                              <2> 
    79                              <2> struc multiboot_info
    80 00000000 <res 00000004>      <2> .flags		resd 1 
    81 00000004 <res 00000004>      <2> .mem_lower	resd 1 
    82 00000008 <res 00000004>      <2> .mem_upper	resd 1 
    83 0000000C <res 00000004>      <2> .boot_device resd 1 
    84 00000010 <res 00000004>      <2> .cmdline resd 1 
    85 00000014 <res 00000004>      <2> .mods_count resd 1 
    86 00000018 <res 00000004>      <2> .mods_addr resd 1 
    87 0000001C <res 00000010>      <2> .syms resd 4 
    88 0000002C <res 00000004>      <2> .mmap_length resd 1 
    89 00000030 <res 00000004>      <2> .mmap_addr resd 1 
    90 00000034 <res 00000004>      <2> .drives_length resd 1 
    91 00000038 <res 00000004>      <2> .drive_addr resd 1 
    92 0000003C <res 00000004>      <2> .config_table resd 1 
    93 00000040 <res 00000004>      <2> .boot_loader_name resd 1 
    94 00000044 <res 00000004>      <2> .apm_table resd 1 
    95 00000048 <res 00000004>      <2> .vbe_control_info resd 1 
    96 0000004C <res 00000004>      <2> .vbe_mode_info resd 1 
    97 00000050 <res 00000002>      <2> .vbe_mode resw 1
    98 00000052 <res 00000002>      <2> .vbe_interface_seg resw 1 
    99 00000054 <res 00000002>      <2> .vbe_interface_off resw 1 
   100 00000056 <res 00000002>      <2> .vbe_interface_len resw 1  
   101                              <2> endstruc
   102                              <2> 
   103                              <1> 
   104                              <1> ;;
   105                              <1> ;; This is the sartoris multiboot header.
   106                              <1> ;; This header will be placed at the begining of the os image.
   107                              <1> ;;
   108                              <1> 
   109                              <1> ;; checksum = 0xFFFFFFFF & ~(flags + magic)
   110                              <1> 
   111                              <1> %define calc_checksum(flags) (0xFFFFFFFF & ~((flags) + MULTIBOOTH_MAGIC) + 1)
   112                              <1> 
   113                              <1> %define total_64kb_chunks 7
   114                              <1> %define img_sectors (total_64kb_chunks * 128) 
   115                              <1> %define img_size (img_sectors * 512)
   116                              <1> %define entry_addr (image_phys_pos+0x30)
   117                              <1> 
   118                              <1> %define boot_info_size 0x58				;; 88 bytes
   119                              <1> 
   120                              <1> %define image_phys_pos 0x102000		;; we intend our kernel image to be placed here
   121                              <1> 
   122                              <1> sartoris_multiboot_header:
   123                              <1> istruc multiboot_header
   124 00000000 02B0AD1B            <1> at multiboot_header.magic,		dd MULTIBOOTH_MAGIC
   125 00000004 02000200            <1> at multiboot_header.flags,		dd MULTIBOOTH_FLAG_ADDRINH | MULTIBOOTH_FLAG_MEM	;; our img will be in binary form, and mem info is required
   126 00000008 FC4F50E4            <1> at multiboot_header.checksum,	dd calc_checksum(MULTIBOOTH_FLAG_ADDRINH | MULTIBOOTH_FLAG_MEM)
   127 0000000C 00201000            <1> at multiboot_header.header_addr, dd image_phys_pos	;; kernel image along with init must be placed here
   128 00000010 00201000            <1> at multiboot_header.load_addr,	dd image_phys_pos	;; The offset in the OS image file at which to start loading is defined by the offset 
   129                              <1> 															;; at which the header was found, minus (header_addr - load_addr)
   130 00000014 00000000            <1> at multiboot_header.load_end_addr,	dd 0x0		;; If this field is zero, the boot loader assumes that the text and data 
   131                              <1> 															;; segments occupy the whole OS image file. 
   132 00000018 00000000            <1> at multiboot_header.bss_end_addr,	dd 0x0		;; If this field is zero, the boot loader assumes that no bss segment is present. 
   133 0000001C 30201000            <1> at multiboot_header.entry_addr,		dd entry_addr
   134                              <1> ;; Next is not required for we will initialize without vbe
   135                              <1> ;;at multiboot_header.mode_type,		dd
   136                              <1> ;;at multiboot_header.width,			dd
   137                              <1> ;;at multiboot_header.height,			dd
   138                              <1> ;;at multiboot_header.depth,			dd
   139 00000020 00<rept>            <1> iend
   140                                  
   141                                  ;; Machine state when we are runned is:
   142                                  
   143                                  ;; EAX contains the magic value 0x2BADB002
   144                                  ;; EBX contains the 32-bit physical address of the Multiboot information structure provided by the boot loader. 
   145                                  ;; CS is a 32-bit read/execute code segment with an offset of 0 and a limit of 0xFFFFFFFF. The exact value is undefined. 
   146                                  ;; DS,ES,FS,GS,SS are 32-bit read/write data segment with an offset of 0 and a limit of 0xFFFFFFFF. The exact values are all undefined. 
   147                                  ;;
   148                                  ;; A20 gate is enabled. 
   149                                  ;; CR0 Bit 31 (PG) is cleared. Bit 0 (PE) is set. Other bits are all undefined. 
   150                                  ;; EFLAGS 
   151                                  ;;		Bit 17 (VM) is cleared. Bit 9 (IF) is cleared. Other bits are all undefined. 
   152                                  ;;		All other processor registers and flag bits are undefined. 
   153                                  
   154                                  %define multiboot_info_address   0x100000		;; we will place multiboot info here
   155                                  %define kernel_address 0x00000000				;; we will place the kernel here
   156                                  %define init_address   0x00800000				;; we will place the init image here
   157                                  %define stack_address  0x000a0000 - 0x4			;; we will place the stack here
   158                                  
   159                                  %define loader_sectors 1
   160                                  
   161                                  %define realaddress(x) ((x) + (image_phys_pos))
   162                                  
   163                                  bits 32
   164                                  
   165                                  ;; . <-- this is the entry point (And also this is possition 0 on the kernel img.)
   166                                  ep:
   167                                  	;; check we where loaded by a multiboot loader
   168 00000030 3D02B0AD1B              	cmp eax, MULTIBOOTH_MAGIC
   169 00000035 0F8593000000            	jne near die							;; if not loaded by a multiboot loader, die!
   170                                  
   171                                  	;; - Even though the segment registers are set up as described above, the GDTR may be invalid, so the OS image must 
   172                                  	;; not load any segment registers (even just reloading the same values!) until it sets up its own GDT. 
   173                                  	;; - The OS image must leave interrupts disabled until it sets up its own IDT.
   174                                  	
   175                                  	;; load gdt and idt with our tables
   176 0000003B 0F0115[E8201000]        	lgdt [realaddress(_gdt_pseudo_descr)]
   177 00000042 0F011D[EE201000]        	lidt [realaddress(_idt_pseudo_descr)]
   178                                  	
   179                                  	;; jump to cs:ep2
   180 00000049 EA[50201000]0800        	jmp 0x8:(image_phys_pos + ep2)
   181                                  ep2:
   182                                  
   183                                  	;; now it's safe to load our segment registers :D
   184 00000050 66B81000                	mov ax, 0x0010
   185 00000054 8ED8                    	mov ds, ax 
   186 00000056 8EC0                    	mov es, ax
   187 00000058 8ED0                    	mov ss, ax
   188                                  
   189                                  	;; ebx contains the 32 bit physical address of the multiboot inf structure
   190                                  	;; as our data segment base address is 0, it's ok to use that address as it
   191                                  	;; was left by multiboot
   192                                  	;; mov eax,[ebx + multiboot_info.xxxx]
   193                                  
   194                                  	;; copy bootinfo struct
   195 0000005A B916000000              	mov ecx, ((boot_info_size) >> 2)
   196 0000005F 89DE                    	mov esi, ebx
   197 00000061 BF00001000              	mov edi, multiboot_info_address
   198 00000066 FC                      	cld
   199 00000067 F3                      	rep
   200 00000068 A5                      	movsd
   201                                  
   202                                  	;; copy mmap if there is one
   203 00000069 8B03                    	mov eax, [ebx + multiboot_info.flags]
   204 0000006B A940000000              	test eax, MBOOTINFO_FLAGMMAP
   205 00000070 742D                    	jz nommap
   206                                  
   207 00000072 8B6B2C                  	mov ebp, [ebx + multiboot_info.mmap_length]
   208 00000075 81FD00000000            	cmp ebp, 0
   209 0000007B 7422                    	je nommap
   210                                  
   211                                  	;; copy mmap and update bootinfo pointer :)
   212 0000007D 8B7330                  	mov esi, [ebx + multiboot_info.mmap_addr]	 ;; source
   213 00000080 BF58001000              	mov edi, multiboot_info_address + boot_info_size ;; dest
   214                                  
   215                                  copymmap_entry:
   216 00000085 8B0E                    	mov ecx, [esi]	;; get member size
   217                                  	
   218 00000087 FC                      	cld
   219 00000088 F3                      	rep
   220 00000089 A4                      	movsb
   221                                  	
   222                                  	;; esi and edi are now at the begining of the next map item
   223                                  
   224 0000008A 4D                      	dec ebp
   225 0000008B 81FD00000000            	cmp ebp,0
   226 00000091 75F2                    	jne copymmap_entry
   227                                  
   228 00000093 BB00001000              	mov ebx, multiboot_info_address
   229 00000098 C7433058001000          	mov dword [ebx + multiboot_info.mmap_addr], (multiboot_info_address + boot_info_size)
   230                                  nommap:
   231                                  	;; move the kernel down to 0x0
   232 0000009F B900150000              	mov ecx, (((kern_sectors - loader_sectors) * 512) >> 2)		;; how many bytes will we copy? (we ignore loader sectors)
   233 000000A4 BE00221000              	mov esi, image_phys_pos+(loader_sectors*512)		;; where do we start? (this is the value in our 
   234                                  								;; multiboot header + size of this loader)
   235 000000A9 BF00000000              	mov edi, kernel_address					;; destination
   236 000000AE FC                      	cld
   237 000000AF F3                      	rep
   238 000000B0 A5                      	movsd
   239                                  
   240                                  	;; place init img where it should be
   241 000000B1 B900AA0100              	mov ecx, ( (img_sectors - (kern_sectors + loader_sectors)) * 512) >> 2	;; ignore kernel and loader sectors
   242 000000B6 BE00781000              	mov esi, image_phys_pos + (kern_sectors + loader_sectors)*512
   243 000000BB BF00008000              	mov edi, init_address
   244 000000C0 F3                      	rep
   245 000000C1 A5                      	movsd
   246                                  	
   247                                  	;; ok, we have copied the kernel down, and the init service up.
   248                                  	;; let's jump to the kernel initialization routines.
   249                                  
   250 000000C2 BCFCFF0900              	mov esp, stack_address		;; don't forget to setup the stack 
   251                                  
   252 000000C7 EA000000000800          	jmp dword 0x8:0x0	; kernel init running!
   253                                  	
   254                                  die:
   255 000000CE EBFE                    	jmp $
   256                                  	
   257                                  	
   258                                  ;; gdt table we will load
   259                                  gdt:	
   260                                  
   261 000000D0 0000000000000000        dw 0, 0, 0, 0	; dummy descriptor
   262                                  	
   263 000000D8 FFFF                    dw 0xffff ; limit=ffff	
   264 000000DA 0000                    dw 0x0000 ; base_adress=0
   265 000000DC 009A                    dw 0x9a00 ; p-flag=1, dpl=0, s-flag=1 (non-system segment), type code exec/read
   266 000000DE CF00                    dw 0x00cf ; g-flag=1, d/b bit=1	(limit mult by 4096, default 32-bit opsize), limit upper bits F
   267                                  
   268 000000E0 FFFF                    dw 0xffff ; limit=ffff
   269 000000E2 0000                    dw 0x0000 ; base_adress=0
   270 000000E4 0092                    dw 0x9200 ; p-flag=1, dpl=0, s-flag=1, type read/write
   271 000000E6 CF00                    dw 0x00cf ; g-flag=1, d/b bit=1	, limit upper bits F
   272                                  	
   273                                  _gdt_pseudo_descr:	
   274 000000E8 3000                    	dw 0x0030		; gdt_limit=48 (3 descriptors)
   275 000000EA [D020]1000              	dw (gdt + (image_phys_pos & 0x0000FFFF)), (image_phys_pos >> 16)
   276                                  	
   277                                  _idt_pseudo_descr:	
   278 000000EE 0000                    	dw 0x0000		; interrupts will be desabled until 
   279 000000F0 00000000                	dw 0x0000, 0x0000	; the real system tables are ready.
   280                                  	
   281                                  	
   282 000000F4 00<rept>                times (512-($-$$)) db 0x0 	;; fill with 0's
   283                                  
