     1                                  
     2                                  ;; note: if execseg16 is changed, make sure to update the _gdt_pseudo_descr
     3                                  ;;       to point to the new GDT in flat mode. santiago.
     4                                  
     5                                  
     6                                  ;;
     7                                  ;; This will conform sartoris Stage 2 boot sector. This stage is 
     8                                  ;; (Almost, because we won't support video modes changing) Multiboot conforming.
     9                                  ;;
    10                                  
    11                                  %include "multiboot.inc"
    12                              <1> 
    13                              <1> ;;
    14                              <1> ;; Nasm struct definitions for multiboot.
    15                              <1> ;;
    16                              <1> 
    17                              <1> struc multiboot_header
    18 00000000 <res 00000004>      <1> .magic resd 1					;; 0 u32 magic 
    19 00000004 <res 00000004>      <1> .flags resd 1					;; 4 u32 flags
    20 00000008 <res 00000004>      <1> .checksum resd 1				;; 8 u32 checksum  required 
    21 0000000C <res 00000004>      <1> .header_addr resd 1				;; 12 u32 header_addr if flags[16] is set 
    22 00000010 <res 00000004>      <1> .load_addr resd 1				;; 16  u32  load_addr  if flags[16] is set 
    23 00000014 <res 00000004>      <1> .load_end_addr resd 1           ;; 20  u32  load_end_addr  if flags[16] is set 
    24 00000018 <res 00000004>      <1> .bss_end_addr resd 1            ;; 24  u32  bss_end_addr  if flags[16] is set 
    25 0000001C <res 00000004>      <1> .entry_addr resd 1				;; 28  u32  entry_addr  if flags[16] is set 
    26 00000020 <res 00000004>      <1> .mode_type resd 1				;; 32  u32  mode_type  if flags[2] is set 
    27 00000024 <res 00000004>      <1> .width resd 1					;; 36  u32  width  if flags[2] is set 
    28 00000028 <res 00000004>      <1> .height resd 1					;; 40  u32  height  if flags[2] is set 
    29 0000002C <res 00000004>      <1> .depth resd 1					;; 44  u32  depth  if flags[2] is set 
    30                              <1> endstruc
    31                              <1> 
    32                              <1> %define MULTIBOOTH_MAGIC 0x1BADB002
    33                              <1> %define MULTIBOOTH_FLAG_PAGEALIGN   0x1		;; bit 0 is 1
    34                              <1> %define MULTIBOOTH_FLAG_MEM         0x2		;; bit 1 is 1
    35                              <1> %define MULTIBOOTH_FLAG_VIDEO       0x4		;; bit 3 is 1
    36                              <1> %define MULTIBOOTH_FLAG_ADDRINH     0x20000		;; bit 16 is 1
    37                              <1> 
    38                              <1> ;;	 0       | flags             |    (required)
    39                              <1> ;;           +-------------------+
    40                              <1> ;;   4       | mem_lower         |    (present if flags[0] is set)
    41                              <1> ;;   8       | mem_upper         |    (present if flags[0] is set)
    42                              <1> ;;           +-------------------+
    43                              <1> ;;   12      | boot_device       |    (present if flags[1] is set)
    44                              <1> ;;           +-------------------+
    45                              <1> ;;   16      | cmdline           |    (present if flags[2] is set)
    46                              <1> ;;           +-------------------+
    47                              <1> ;;   20      | mods_count        |    (present if flags[3] is set)
    48                              <1> ;;   24      | mods_addr         |    (present if flags[3] is set)
    49                              <1> ;;           +-------------------+
    50                              <1> ;;   28 - 40 | syms              |    (present if flags[4] or
    51                              <1> ;;           |                   |                flags[5] is set)
    52                              <1> ;;           +-------------------+
    53                              <1> ;;   44      | mmap_length       |    (present if flags[6] is set)
    54                              <1> ;;   48      | mmap_addr         |    (present if flags[6] is set)
    55                              <1> ;;           +-------------------+
    56                              <1> ;;   52      | drives_length     |    (present if flags[7] is set)
    57                              <1> ;;   56      | drives_addr       |    (present if flags[7] is set)
    58                              <1> ;;           +-------------------+
    59                              <1> ;;   60      | config_table      |    (present if flags[8] is set)
    60                              <1> ;;           +-------------------+
    61                              <1> ;;   64      | boot_loader_name  |    (present if flags[9] is set)
    62                              <1> ;;           +-------------------+
    63                              <1> ;;   68      | apm_table         |    (present if flags[10] is set)
    64                              <1> ;;           +-------------------+
    65                              <1> ;;   72      | vbe_control_info  |    (present if flags[11] is set)
    66                              <1> ;;   76      | vbe_mode_info     |
    67                              <1> ;;   80      | vbe_mode          |
    68                              <1> ;;   82      | vbe_interface_seg |
    69                              <1> ;;   84      | vbe_interface_off |
    70                              <1> ;;   86      | vbe_interface_len |
    71                              <1> 
    72                              <1> %define MBOOTINFO_FLAGMEM 0x1
    73                              <1> %define MBOOTINFO_FLAGMMAP 0x40
    74                              <1> 
    75                              <1> struc multiboot_info
    76 00000000 <res 00000004>      <1> .flags		resd 1 
    77 00000004 <res 00000004>      <1> .mem_lower	resd 1 
    78 00000008 <res 00000004>      <1> .mem_upper	resd 1 
    79 0000000C <res 00000004>      <1> .boot_device resd 1 
    80 00000010 <res 00000004>      <1> .cmdline resd 1 
    81 00000014 <res 00000004>      <1> .mods_count resd 1 
    82 00000018 <res 00000004>      <1> .mods_addr resd 1 
    83 0000001C <res 00000010>      <1> .syms resd 4 
    84 0000002C <res 00000004>      <1> .mmap_length resd 1 
    85 00000030 <res 00000004>      <1> .mmap_addr resd 1 
    86 00000034 <res 00000004>      <1> .drives_length resd 1 
    87 00000038 <res 00000004>      <1> .drive_addr resd 1 
    88 0000003C <res 00000004>      <1> .config_table resd 1 
    89 00000040 <res 00000004>      <1> .boot_loader_name resd 1 
    90 00000044 <res 00000004>      <1> .apm_table resd 1 
    91 00000048 <res 00000004>      <1> .vbe_control_info resd 1 
    92 0000004C <res 00000004>      <1> .vbe_mode_info resd 1 
    93 00000050 <res 00000002>      <1> .vbe_mode resw 1
    94 00000052 <res 00000002>      <1> .vbe_interface_seg resw 1 
    95 00000054 <res 00000002>      <1> .vbe_interface_off resw 1 
    96 00000056 <res 00000002>      <1> .vbe_interface_len resw 1  
    97                              <1> endstruc
    98                              <1> 
    99                                  %include "stages.inc"
   100                              <1> 
   101                              <1> ;;
   102                              <1> ;;	This file contains defines used in both stage 1 and stage 2 loaders.
   103                              <1> ;;
   104                              <1> 
   105                              <1> ;; real-mode segments 
   106                              <1> %define bootseg16		0x07c0	; BIOS shall drop us there
   107                              <1> %define	stage1_5seg16		0x0800	; stage 1.5 block will be copied here (this has to be within the range of the boot seg)
   108                              <1> %define stage1_5bufseg16	0x1000	; 0x10000 to 0x20000 will be used as a buffer for reading from devices (buffer must be physicaly aligned on 64k boundaries for DMA transfers)
   109                              <1> %define	stage2seg16		0x2000	; stage 2 will be copied here
   110                              <1> %define stckseg16		0x9000	; stack for real mode operation
   111                              <1> 
   112                              <1> %define mbootinfseg16		0x0800	; where we will place Multiboot info on stage 2 until it's copied to it's location
   113                              <1> 
   114                              <1> %define mmap_offset		0xFF	; this ofset is within mbootinfseg16 segment
   115                              <1> 
   116                              <1> ;; 32 bits physical address
   117                              <1> %define mbootinfaddr		(mbootinfseg16*0x10)	; Physical address for multiboot
   118                              <1> %define	stage2addr		0x20000	; stage 2 physical address
   119                                  
   120                                  %define stage_2_blocks 2 ;; MODIFIED BY NICO
   121                                     
   122                                  %define realaddress(x) (x + (stage2seg16*0x10-bootseg16*0x10))
   123                                  
   124                                  bits 16
   125                                  
   126                                  stage2_entry:
   127                                  
   128                                  	;; stage 2 has been loaded completely in memory
   129                                  	;; NOTE: On Sartoris Stage 2 is supposed to contain the init image.
   130                                  	
   131                                  	;; stage 1.5 loader must have left:
   132                                  	;; ds:si = segment:ofeset of disk address packet/drive geometry
   133                                  	;; dl = drive num
   134                                  	;; ax = stage 2 image size
   135                                  	;; this must have been left this way by the 1.5
   136                                  	;; loader
   137                                  	
   138                                  	;; sartoris Stage 2 loader is not as complex as a real
   139                                  	;; boot loader like grub. This is only ment to cover the
   140                                  	;; Multiboot procedure, and if a real bootloader 
   141                                  	;; is needed (for selecting different kernel versions, etc)
   142                                  	;; this one cannot be used.
   143                                  	
   144                                  	;; cx will hold image size (in blocks) without stage 2 loader size
   145 00000000 89C1                    	mov cx, ax 
   146 00000002 81E90200                	sub cx, stage_2_blocks
   147                                  	
   148                                  	;; ds will point to stage2seg16
   149 00000006 B80020                  	mov ax, stage2seg16
   150 00000009 8ED8                    	mov ds, ax
   151                                  	
   152                                  	;; bx will point to the Multiboot header 
   153 0000000B 6631DB                  	xor ebx, ebx
   154 0000000E BB0200                  	mov bx, stage_2_blocks
   155 00000011 C1E309                  	shl bx, 9				;; multiply by 512
   156                                  	
   157                                  	;; check first value is the magic number
   158 00000014 66813F02B0AD1B          	cmp dword [bx], MULTIBOOTH_MAGIC
   159 0000001B 0F858200                	jne near error
   160                                  	
   161                                  	;; use checksum for checking flags and magic number
   162 0000001F 668B07                  	mov eax, [bx]
   163 00000022 66034704                	add eax, [bx + 4]
   164 00000026 66034708                	add eax, [bx + 8]
   165                                  	
   166 0000002A 663D00000000            	cmp eax, 0
   167 00000030 0F856D00                	jne near error
   168                                  	
   169                                  	;; FIXME: we should check flags, but we already know what sartoris 
   170                                  	;; needs, so it should be added here.
   171                                  	
   172                                  	;; setup things so the image can be run
   173                                  
   174                                  ;; enable A20
   175                                  	
   176 00000034 E86C00                  	call empty_kb_buf	
   177                                  
   178 00000037 B0D1                    	mov al, 0xd1
   179 00000039 E664                    	out 0x64, al		; 0xd1 -> port 0x64: write the following data
   180                                  				; byte to the output port
   181 0000003B E86500                  	call empty_kb_buf
   182 0000003E B0DF                    	mov al, 0xdf		; i think bit 1 of the outputport is the A20, 
   183 00000040 E660                    	out 0x60, al		; but sending 0xdf seems to work. need info on
   184                                  				; this.
   185                                  	
   186 00000042 E85E00                  	call empty_kb_buf	; A20 up, hopefully
   187                                  
   188                                  ;; memory size
   189                                  
   190                                  	;; attempt getting memory size from BIOS
   191 00000045 E88600                  	call get_mem_size
   192                                  
   193                                  ;; switch to p-mode
   194                                  
   195 00000048 FA                      	cli
   196                                  	
   197 00000049 0F0116[C200]            	lgdt [_gdt_pseudo_descr]
   198 0000004E 0F011E[C800]            	lidt [_idt_pseudo_descr]
   199                                  	
   200 00000053 0F20C0                  	mov eax, cr0
   201 00000056 660D01000000            	or eax, 1
   202 0000005C 0F22C0                  	mov cr0, eax
   203                                  
   204 0000005F 66EA[67000200]0800      	jmp dword 0x0008:(stage2seg16*0x10 + go32)		; mama!
   205                                  go32:		
   206                                  bits 32
   207                                  
   208 00000067 66B81000                	mov ax, 0x0010
   209 0000006B 8ED8                    	mov ds, ax 
   210 0000006D 8EC0                    	mov es, ax
   211 0000006F 8ED0                    	mov ss, ax
   212 00000071 8EE0                    	mov fs, ax
   213 00000073 8EE8                    	mov gs, ax
   214                                  
   215                                  	;; the header on sartoris is placed at the begining of the kernel image
   216                                  	;; so multiboot_header.header_addr tell us where we should load the 
   217                                  	;; image
   218                                  	
   219 00000075 BB00040200              	mov ebx, stage2addr + stage_2_blocks*512
   220                                  
   221                                  	;; move the kernel image to its position
   222 0000007A 31C0                    	xor eax, eax
   223 0000007C 6689C8                  	mov ax, cx			;; cx has image size in blocks, without stage loader 2 size
   224 0000007F C1E007                  	shl eax, 7			;; multiply by 512 / 4
   225                                  	
   226 00000082 89C1                    	mov ecx, eax
   227 00000084 8B730C                  	mov esi, [ebx + multiboot_header.header_addr]	; from
   228 00000087 2B7310                  	sub esi, [ebx + multiboot_header.load_addr]
   229 0000008A 01DE                    	add esi, ebx
   230 0000008C 8B7B0C                  	mov edi, [ebx + multiboot_header.header_addr]	; to
   231 0000008F FC                      	cld
   232 00000090 F3                      	rep
   233 00000091 A5                      	movsd
   234                                  	
   235                                  ;; EAX contains the magic value 0x2BADB002
   236                                  ;; EBX contains the 32-bit physical address of the Multiboot information structure provided by the boot loader. 
   237                                  ;; CS is a 32-bit read/execute code segment with an ofeset of 0 and a limit of 0xFFFFFFFF. The exact value is undefined. 
   238                                  ;; DS,ES,es,GS,SS are 32-bit read/write data segment with an ofeset of 0 and a limit of 0xFFFFFFFF. The exact values are all undefined. 
   239                                  ;;
   240                                  ;; A20 gate is enabled. 
   241                                  ;; CR0 Bit 31 (PG) is cleared. Bit 0 (PE) is set. Other bits are all undefined. 
   242                                  ;; EFLAGS 
   243                                  ;;		Bit 17 (VM) is cleared. Bit 9 (IF) is cleared. Other bits are all undefined. 
   244                                  ;;		All other processor registers and flag bits are undefined. 
   245                                  
   246 00000092 8B531C                  	mov edx, [ebx + multiboot_header.entry_addr]
   247                                  
   248 00000095 B802B0AD1B              	mov eax, MULTIBOOTH_MAGIC
   249 0000009A BB00800000              	mov ebx, mbootinfaddr
   250                                  	
   251 0000009F FFE2                    	jmp edx		; this should jump to 0x8:edx
   252                                  
   253                                  bits 16
   254                                  
   255                                  error:
   256 000000A1 EBFE                    	jmp $
   257                                  
   258                                  empty_kb_buf:			; this is the standard way, i belive.
   259 000000A3 E464                    	in al, 0x64
   260 000000A5 2402                    	and al, 0x02
   261 000000A7 75FA                    	jnz empty_kb_buf
   262 000000A9 C3                      	ret
   263                                  
   264                                  
   265                                  ;; this system tables are temporary, the kernel will
   266                                  ;; update them later
   267                                  
   268                                  gdt:	
   269                                  
   270 000000AA 0000000000000000        dw 0, 0, 0, 0	; dummy descriptor
   271                                  	
   272 000000B2 FFFF                    dw 0xffff ; limit=ffff	
   273 000000B4 0000                    dw 0x0000 ; base_adress=0
   274 000000B6 009A                    dw 0x9a00 ; p-flag=1, dpl=0, s-flag=1 (non-system segment), type code exec/read
   275 000000B8 CF00                    dw 0x00cf ; g-flag=1, d/b bit=1	(limit mult by 4096, default 32-bit opsize), limit upper bits F
   276                                  
   277 000000BA FFFF                    dw 0xffff ; limit=ffff
   278 000000BC 0000                    dw 0x0000 ; base_adress=0
   279 000000BE 0092                    dw 0x9200 ; p-flag=1, dpl=0, s-flag=1, type read/write
   280 000000C0 CF00                    dw 0x00cf ; g-flag=1, d/b bit=1	, limit upper bits F
   281                                  	
   282                                  _gdt_pseudo_descr:	
   283 000000C2 3000                    	dw 0x0030		; gdt_limit=48 (3 descriptors)
   284 000000C4 [AA00]0200              	dw (gdt + (stage2seg16 & 0x0FFF)), (stage2seg16 >> 12)
   285                                  	
   286                                  _idt_pseudo_descr:	
   287 000000C8 0000                    	dw 0x0000		; interrupts will be desabled until 
   288 000000CA 00000000                	dw 0x0000, 0x0000	; the real system tables are ready.
   289                                  
   290                                  bits 16
   291                                  
   292                                  ;; This function will attempt getting memory size 
   293                                  ;; by using different methods
   294                                  ;; this function will not preserve: es, si, ax, bx, dx, cx
   295                                  get_mem_size:
   296                                  	
   297                                  	;; set es:si to multiboot info structure possition
   298 000000CE B80008                  	mov ax, mbootinfseg16
   299 000000D1 8EC0                    	mov es, ax
   300 000000D3 31F6                    	xor si, si
   301                                  
   302                                  	;; set multiboot info flag
   303 000000D5 6631C0                  	xor eax, eax
   304 000000D8 660D01000000            	or eax, MBOOTINFO_FLAGMEM
   305 000000DE 26668904                	mov [es:si + multiboot_info.flags], eax
   306                                  
   307                                  
   308 000000E2 BA0000                  	mov dx, 0 ;; conventional
   309 000000E5 E87800                  	call get_msize
   310 000000E8 2666894404              	mov [es:si + multiboot_info.mem_lower], eax
   311 000000ED BA0100                  	mov dx, 1 ;; extended
   312 000000F0 E86D00                  	call get_msize
   313 000000F3 2666894408              	mov [es:si + multiboot_info.mem_upper], eax
   314                                  
   315                                  	;; attempt getting an mmap
   316 000000F8 2666C7442C00000000      	mov dword [es:si + multiboot_info.mmap_length], 0									;; initial length
   317 00000101 2666C74430FF800000      	mov [es:si + multiboot_info.mmap_addr], dword ((mbootinfseg16<<4) + mmap_offset)	;; physical address for mmap
   318                                  	
   319 0000010A 6631FF                  	xor edi, edi
   320 0000010D BFFF00                  	mov di, mmap_offset
   321 00000110 6631DB                  	xor ebx, ebx
   322 00000113 66BD00000000            	mov ebp, 0				;; ebp will hold length
   323                                  	;jmp getmmap_finished	;; FIXME: I'm testing if this function is failing
   324                                  getmmap_loop:
   325 00000119 E85E00                  	call get_mmap
   326 0000011C 6681FB00000000          	cmp ebx, 0
   327 00000123 7406                    	je getmmap_finished
   328 00000125 2666033D                	add edi, [es:di]		;; increment buffer possition
   329 00000129 EBEE                    	jmp getmmap_loop
   330                                  getmmap_finished:
   331 0000012B 2666896C2C              	mov dword [es:si + multiboot_info.mmap_length], ebp 
   332                                  
   333 00000130 6681FD00000000          	cmp ebp, 0
   334 00000137 7408                    	je use_get_mem_2
   335                                  
   336                                  	;; Set mmap flag
   337 00000139 2666810C40000000        	or [es:si + multiboot_info.flags], dword MBOOTINFO_FLAGMMAP
   338                                  	
   339                                  	;; I will try to cap high mem using mem2 system, so let it go through 
   340                                  	;; NOTE: I could also cap upper by going through the mmap,
   341                                  	;; but I'll leave that to others :D
   342                                  
   343                                  use_get_mem_2:
   344                                  	;; attempt getting mem size using function 0xE801
   345 00000141 E8AF00                  	call get_mem2
   346                                  
   347 00000144 663DFFFFFFFF            	cmp eax, 0xffffffff
   348 0000014A 7413                    	je get_mem_finished
   349                                  
   350                                  	;; set high mem
   351 0000014C 6681E3FFFF0000          	and ebx, 0x0000ffff
   352 00000153 66C1E306                	shl ebx, 6	;; convert to Kilobytes
   353 00000157 6601D8                  	add eax, ebx
   354                                  	
   355 0000015A 2666894408              	mov [es:si + multiboot_info.mem_upper], eax
   356                                  
   357                                  get_mem_finished:
   358 0000015F C3                      	ret
   359                                  
   360                                  ;; Get mem size by int 12h or 15h
   361                                  ;; dx = 1 then ext, dx = 0 conv.
   362                                  ;; returned in eax
   363                                  get_msize:
   364 00000160 6631C0                  	xor eax,eax
   365                                  
   366 00000163 81FA0100                	cmp dx, 1
   367 00000167 7405                    	je get_msize_ext
   368                                  
   369 00000169 CD12                    	int 0x12
   370                                  
   371 0000016B E90400                  	jmp get_msize_done
   372                                  get_msize_ext:
   373                                  
   374 0000016E B488                    	mov ah, 0x88
   375 00000170 CD15                    	int 0x15	
   376                                  
   377                                  get_msize_done:
   378 00000172 89C3                    	mov bx, ax
   379 00000174 6631C0                  	xor eax,eax
   380 00000177 89D8                    	mov ax, bx
   381                                  
   382 00000179 C3                      	ret
   383                                  
   384                                  ;; this function will call int 15 function 0xE820
   385                                  ;; parameters are:
   386                                  ;; ebx: continuation value or 0 for the begining of the map
   387                                  ;; es:di = buffer of 20 bytes
   388                                  ;; ebp: size of buffer read so far (initialy 0)
   389                                  ;; returns: 
   390                                  ;; ebx: continuation value
   391                                  ;; this function will not preserve ax, bx, cx, dx
   392                                  get_mmap:
   393                                  
   394 0000017A 66B820E80000            	mov eax, 0x0000e820
   395 00000180 66BA50414D53            	mov edx, 0x534D4150 ;; 'SMAP'	
   396 00000186 66B914000000            	mov ecx, 0x14
   397                                  	;; ebx already has the cont value
   398                                  	;; es:di already points at the buffer, bu we will add size to it
   399 0000018C 2666C70500000000        	mov dword [es:di], 0
   400 00000194 81C70400                	add di, 4
   401                                  
   402 00000198 CD15                    	int 0x15
   403                                  
   404                                  	;; if this is not the first attempt (meaning esp != 0)
   405                                  	;; if carry is returned or ebx = 0 we must count the last entry
   406 0000019A 6681FD00000000          	cmp ebp, 0
   407 000001A1 751D                    	jne get_mmap_not_first
   408                                  	
   409                                  	;; Not first time, perform common checks
   410 000001A3 723D                    	jc nommap
   411                                  
   412 000001A5 663D50414D53            	cmp eax, 0x534D4150 ;; 'SMAP'	
   413 000001AB 7535                    	jne nommap
   414                                  
   415 000001AD 6681F914000000          	cmp ecx, 0x14
   416 000001B4 752C                    	jne nommap
   417                                  	
   418 000001B6 6681C518000000          	add ebp, 0x18	;; increment here for it's the first
   419                                  	
   420 000001BD E91200                  	jmp get_mmap_cont
   421                                  get_mmap_not_first:
   422 000001C0 6681C518000000          	add ebp, 0x18		;; increment counter on 1
   423                                  	
   424                                  	;; if carry or ebx = 0, this is the last record
   425 000001C7 7219                    	jc nommap
   426                                  	
   427 000001C9 6681F914000000          	cmp ecx, 0x14
   428 000001D0 7510                    	jne nommap
   429                                  	
   430                                  get_mmap_cont:
   431 000001D2 6681C104000000          	add ecx, 4 		;; include size on the size :S
   432                                  
   433                                  mmapok:			
   434 000001D9 81EF0400                	sub di, 4	;; return buffer pointer as it was
   435 000001DD 2666890D                	mov [es:di], ecx
   436 000001E1 C3                      	ret
   437                                  nommap:
   438 000001E2 66BB00000000            	mov ebx, 0x0
   439 000001E8 66B900000000            	mov ecx, 0
   440 000001EE 81EF0400                	sub di, 4	;; return buffer pointer as it was
   441 000001F2 C3                      	ret
   442                                  	
   443                                  ;; if failed eax will be 0xffffffff, else 0x0000XXXX 
   444                                  ;; where XXXX has the lower part and bx the higher
   445                                  get_mem2:
   446 000001F3 66B801E80000            	mov eax, 0x0000E801
   447 000001F9 CD15                    	int 0x15
   448                                  	
   449 000001FB 7216                    	jc getmem2fail
   450                                  
   451 000001FD 80FC86                  	cmp ah, 0x86
   452 00000200 7411                    	je getmem2fail
   453                                  
   454 00000202 3D0000                  	cmp ax, 0
   455 00000205 7504                    	jne getmem2cont
   456                                  
   457 00000207 89C8                    	mov ax, cx
   458 00000209 89D3                    	mov bx, dx
   459                                  getmem2cont:
   460 0000020B 89C1                    	mov cx, ax
   461 0000020D 6631C0                  	xor eax, eax
   462 00000210 89C8                    	mov ax, cx
   463 00000212 C3                      	ret
   464                                  getmem2fail:
   465 00000213 66B8FFFFFFFF            	mov eax, 0xffffffff
   466 00000219 C3                      	ret
   467                                  
   468 0000021A 00<rept>                times ((stage_2_blocks*512)-($-$$)) db 0x0 	;; fill with 0's
