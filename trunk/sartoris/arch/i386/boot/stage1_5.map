     1                                  
     2                                  ;;
     3                                  ;;	This is the default loading stage. It will use an encoded blocklist
     4                                  ;;	for loading the remains of stage 2.
     5                                  ;;	This stage could be replaced by other loaders in order to load stage 2
     6                                  ;;	from specific file systems.
     7                                  ;;
     8                                  
     9                                  bits 16	
    10                                  
    11                                  ;; each block list entry will have this format
    12                                  struc blocklist_entry
    13 00000000 <res 00000004>          .block resd 1
    14 00000004 <res 00000002>          .length resw 1
    15                                  endstruc
    16                                  
    17                                  %define realaddress(x) ((x) + (stage1_5seg16*0x10-bootseg16*0x10))
    18                                  
    19                                  %include "stages.inc"
    20                              <1> 
    21                              <1> ;;
    22                              <1> ;;	This file contains defines used in both stage 1 and stage 2 loaders.
    23                              <1> ;;
    24                              <1> 
    25                              <1> ;; real-mode segments 
    26                              <1> %define bootseg16		0x07c0	; BIOS shall drop us there
    27                              <1> %define	stage1_5seg16		0x0800	; stage 1.5 block will be copied here (this has to be within the range of the boot seg)
    28                              <1> %define stage1_5bufseg16	0x1000	; 0x10000 to 0x20000 will be used as a buffer for reading from devices (buffer must be physicaly aligned on 64k boundaries for DMA transfers)
    29                              <1> %define	stage2seg16		0x2000	; stage 2 will be copied here
    30                              <1> %define stckseg16		0x9000	; stack for real mode operation
    31                              <1> 
    32                              <1> %define mbootinfseg16		0x0800	; where we will place Multiboot info on stage 2 until it's copied to it's location
    33                              <1> 
    34                              <1> %define mmap_offset		0xFF	; this ofset is within mbootinfseg16 segment
    35                              <1> 
    36                              <1> ;; 32 bits physical address
    37                              <1> %define mbootinfaddr		(mbootinfseg16*0x10)	; Physical address for multiboot
    38                              <1> %define	stage2addr		0x20000	; stage 2 physical address
    39                                  
    40                                  %define loading_msg_len 7
    41                                  %define boot_msg_len 23    
    42                                  
    43                                  ;; . <-- this is the entry point for stage 1.5
    44                                  stage2_loader:
    45                                  	;; we are now at the stage2seg16 segment
    46                                  	;; ip = cs:0 = stage1_5seg16:0
    47                                  	
    48                                  	;; at this point we should have:
    49                                  	;; ds points to bootseg16
    50                                  	;; ds:si = segment:offset of disk address packet/drive geometry
    51                                  	;; dl = drive num
    52                                  	;; this must have been left this way by the stage 1 (or 1.5)
    53                                  	;; loader
    54                                  	;; We will use the stack left by stage 1.
    55                                  
    56                                  	;; let es hold the boot 
    57                                  	;; we must load reamining bytes for the 2nd stage 
    58                                  	
    59                                  	;; registers will be used this way on load_blocks
    60                                  	;; dl = device num
    61                                  	;; ds:si = stage 1 disk_address_packet/sectors
    62                                  	;; ds:di = offset of current block list node
    63                                  
    64                                  	;; initialize video for printing fancy text xD
    65 00000000 B80300                  	mov ax, 0x0003          ; set display to 80x25 16 color text mode
    66 00000003 CD10                    	int 0x10	
    67                                  
    68                                  	;; preserve drive num
    69 00000005 89E5                    	mov bp, sp
    70 00000007 52                      	push dx
    71 00000008 81EC0200                	sub sp, 2			;; bp + 2 will hold sector count
    72 0000000C C746FC0000              	mov word [bp - 4], 0		
    73                                  	
    74 00000011 60                      	pusha
    75 00000012 8CD8                    	mov ax, ds
    76 00000014 8EC0                    	mov es, ax
    77 00000016 BD[5F05]                	mov bp, realaddress(boot_msg)
    78 00000019 B91700                          mov cx, boot_msg_len
    79 0000001C BA0002                          mov dx, 0x0200
    80 0000001F E82401                          call print_msg          ; print 'bootstrap' message
    81                                  
    82 00000022 BD[5805]                	mov bp, realaddress(loading_msg)
    83 00000025 B90700                          mov cx, loading_msg_len
    84 00000028 BA0004                          mov dx, 0x0400
    85 0000002B E81801                          call print_msg          ; print 'bootstrap' message
    86 0000002E 61                      	popa 
    87                                  
    88                                  	;; read first list entry from ds:di
    89 0000002F BF[8805]                	mov di, realaddress(block_list_start)	
    90                                  	
    91                                  	;; set copy segment to nextstage_seg
    92 00000032 A1[7B05]                	mov ax, [realaddress(nextstage_seg)+2]
    93 00000035 A3[7705]                	mov [realaddress(nextcopy_seg)], ax
    94                                  	
    95                                  	
    96                                  load_blocks:
    97                                  	
    98                                  	;; check there's something to read
    99 00000038 817D040000              	cmp word [di + blocklist_entry.length], 0
   100 0000003D 0F84F000                	je near block_read_finished
   101                                  	
   102 00000041 C606[7605]00            	mov byte [realaddress(tries)], 0
   103                                  	
   104 00000046 807CFF00                	cmp byte [si - 1], 0
   105 0000004A 743E                    	je chs_mode
   106                                  	
   107                                  lba_mode:
   108                                  	
   109                                  	;; load logical sector start
   110 0000004C 668B1D                  	mov ebx, [di + blocklist_entry.block]
   111                                  
   112                                  	;; the maximum is limited to 0x7f because of Phoenix EDD 
   113 0000004F 6631C0                  	xor	eax, eax
   114 00000052 B07F                    	mov al, 0x7f
   115                                  
   116                                  	;; how many do we really want to read?
   117 00000054 394504                  	cmp	[di + blocklist_entry.length], ax
   118                                  
   119 00000057 7F03                    	jg	lba_cont
   120                                  
   121                                  	;; if less than, set to total
   122 00000059 8B4504                  	mov ax, [di + blocklist_entry.length]
   123                                  
   124                                  lba_cont:	
   125                                  	;; subtract from total 
   126 0000005C 294504                  	sub [di + blocklist_entry.length], ax
   127                                  
   128                                  	;; add into logical sector start
   129 0000005F 660105                  	add [di + blocklist_entry.block], eax
   130                                  
   131                                  	;; set up disk address packet 
   132                                  
   133                                  	;; set the size and the reserved byte */
   134 00000062 C7041000                	mov word [si], 0x0010
   135                                  
   136                                  	;; blocks 
   137 00000066 894402                  	mov word [si + 2], ax		
   138                                  	
   139                                  	;; the absolute address (low 32 bits) 
   140 00000069 66895C08                	mov dword [si + 8], ebx
   141                                  	
   142 0000006D 60                      	pusha		;; preserve registers
   143                                  	
   144                                  	;; destination buffer segment 
   145 0000006E B80010                  	mov ax, stage1_5bufseg16
   146 00000071 894406                  	mov [si + 6], ax
   147                                  	
   148                                  
   149 00000074 6631C0                  	xor	eax, eax
   150 00000077 6689440A                	mov [si + 10], eax		;; clear high bits of absolute address
   151 0000007B 894404                  	mov [si + 4], ax		;; clear offset for dest buffer
   152                                  	
   153                                   ;; BIOS call "INT 0x13 Function 0x42" to read sectors from disk into memory
   154                                   ;;	Call with	ah = 0x42
   155                                   ;;				dl = drive number
   156                                   ;;				ds:si = segment:offset of disk address packet
   157                                   ;;	Return:
   158                                   ;;				al = 0x0 on success; err code on failure
   159                                   
   160 0000007E B442                    	mov ah, 0x42
   161 00000080 CD13                    	int	0x13
   162                                  
   163 00000082 61                      	popa 
   164                                  	
   165 00000083 0F82BD00                	jc near read_error
   166                                  
   167 00000087 E97600                  	jmp update_seg
   168                                  	
   169                                  chs_mode: 
   170                                  	
   171                                  	;; get next sector being read onto eax
   172 0000008A 668B05                  	mov eax, [di + blocklist_entry.block]
   173                                  
   174                                  translate_to_chs:
   175                                  	;; translate stage 2 lba to chs
   176                                  	
   177 0000008D 6631D2                  	xor	edx, edx
   178                                  
   179                                  	;; divide by number of sectors 
   180 00000090 66F734                  	div dword [si]
   181                                  
   182                                  	;; save sector start 
   183 00000093 FEC2                    	inc dl						;; sectors goes from 1..N
   184 00000095 88540A                  	mov	[si + 10], dl
   185                                  
   186 00000098 6631D2                  	xor	edx, edx	
   187 0000009B 66F77404                	div dword [si + 4]			;; divide by number of heads
   188                                  
   189                                  	;; save head start 
   190 0000009F 88540B                  	mov [si + 11], dl
   191                                  
   192                                  	;; save cylinder start 
   193 000000A2 89440C                  	mov [si + 12], ax
   194                                  
   195                                  calc_sectors:
   196 000000A5 6631C0                  	xor eax, eax
   197 000000A8 8B04                    	mov ax, [si]            ;; was 0x7f but it should use drive geometry for this and si points to sectors per track
   198 000000AA 31DB                    	xor bx, bx
   199 000000AC 8A5C0A                  	mov bl, [si+10]
   200 000000AF 29D8                    	sub ax, bx		;; substract start sector
   201 000000B1 40                      	inc ax			;; add one, because sectors are numbered from 1...N
   202                                  
   203                                  	;; how many do we really want to read?
   204 000000B2 394504                  	cmp	[di + blocklist_entry.length], ax
   205                                  
   206 000000B5 7F03                    	jg	load_track
   207                                  
   208                                  	;; if less than, set to total
   209 000000B7 8B4504                  	mov ax, [di + blocklist_entry.length]
   210                                  
   211                                  load_track:
   212                                  	;; subtract from total 
   213 000000BA 294504                  	sub [di + blocklist_entry.length], ax
   214                                  
   215                                  	;; add into logical sector start
   216 000000BD 660105                  	add [di + blocklist_entry.block], eax
   217                                  
   218 000000C0 C606[7605]00            	mov byte [realaddress(tries)], 0
   219                                  	
   220                                  	;; bios int 13 parameter translation
   221 000000C5 B402                    	mov ah, 2	; function: read
   222                                  		
   223 000000C7 8B4C0C                  	mov cx, [si + 12]		; sector & track
   224 000000CA 88CA                    	mov dl, cl
   225 000000CC C1E902                  	shr cx, 2
   226 000000CF 80E1C0                  	and cl, 0xc0
   227 000000D2 0A4C0A                  	or cl, [si + 10]
   228 000000D5 88D5                    	mov ch, dl	
   229                                  
   230 000000D7 8A56FE                  	mov dl, [bp - 2]			;; bp - 2 points to the drive num on stack
   231 000000DA 8A740B                  	mov dh, [si + 11]
   232                                  	
   233 000000DD BB0010                  	mov bx, stage1_5bufseg16
   234 000000E0 8EC3                    	mov es, bx
   235 000000E2 31DB                    	xor bx, bx
   236                                  
   237                                  reload:
   238 000000E4 60                      	pusha
   239                                  	
   240                                  ;; BIOS call "INT 0x13 Function 0x2" to read sectors from disk into memory
   241                                  ;;	Call with	ah = 0x2
   242                                  ;;			al = number of sectors
   243                                  ;;			ch = cylinder
   244                                  ;;			cl = sector (bits 6-7 are high bits of "cylinder")
   245                                  ;;			dh = head
   246                                  ;;			dl = drive (0x80 for hard disk, 0x0 for floppy disk)
   247                                  ;;			es:bx = segment:offset of buffer
   248                                  ;;	Return:
   249                                  ;;			ah = 0x0 on success; err code on failure
   250                                  	
   251 000000E5 CD13                    	int 0x13
   252 000000E7 61                      	popa
   253                                  		
   254 000000E8 30E4                    	xor ah, ah
   255                                  		
   256 000000EA 7314                    	jnc update_seg
   257 000000EC 803E[7605]03            	cmp byte [realaddress(tries)], 3
   258                                  bad_media:
   259 000000F1 73FE                    	jae bad_media
   260 000000F3 FE06[7605]              	inc byte [realaddress(tries)]
   261 000000F7 B400                    	mov ah, 0x00
   262 000000F9 8A56FE                  	mov dl, [bp - 2]
   263 000000FC CD13                    	int 0x13	;; reset
   264 000000FE EBE4                    	jmp reload
   265                                  
   266                                  update_seg:
   267                                  	;; ax contains blocks read (no more than 0x7f on lba, and 0xff on chs)
   268                                  
   269                                  	;; increment sectors read
   270 00000100 0146FC                  	add [bp - 4], ax
   271                                  
   272                                  	;; copy data from disk buffer to nextcopy_seg
   273 00000103 60                      	pusha
   274 00000104 1E                      	push ds
   275                                  
   276 00000105 8B1E[7705]              	mov bx, [realaddress(nextcopy_seg)]
   277 00000109 8EC3                    	mov es, bx
   278 0000010B BB0010                  	mov bx, stage1_5bufseg16
   279 0000010E 8EDB                    	mov ds, bx
   280 00000110 31F6                    	xor si, si
   281 00000112 31FF                    	xor di, di
   282                                  
   283 00000114 C1E008                  	shl ax, 8		;; multiply by 512 / 2
   284 00000117 89C1                    	mov cx, ax
   285                                  
   286 00000119 FC                      	cld
   287 0000011A F3                      	rep
   288 0000011B A5                      	movsw 	;; copy buffer
   289                                  
   290 0000011C 1F                      	pop ds
   291 0000011D 61                      	popa
   292                                  
   293                                  	;; update nextcopy_segment
   294 0000011E 8B1E[7705]              	mov bx, [realaddress(nextcopy_seg)]
   295 00000122 C1E005                  	shl ax, 5		
   296 00000125 01C3                    	add bx, ax
   297 00000127 891E[7705]              	mov [realaddress(nextcopy_seg)], bx
   298                                  
   299 0000012B E82100                  	call print_dot	
   300                                  
   301 0000012E E907FF                  	jmp load_blocks
   302                                  
   303                                  block_read_finished:
   304                                  	
   305                                  	;; substract 1 from blocklist len
   306 00000131 FE0E[8705]              	dec byte [realaddress(block_list_len)]
   307                                  	
   308                                  	;; see if next blocklist item must be read
   309 00000135 7407                    	jz run		;; we finished
   310                                  	
   311 00000137 81C70600                	add di, 6	;; move to next block list item
   312 0000013B E9FAFE                  	jmp load_blocks
   313                                  run:
   314 0000013E 58                      	pop ax		;; set ax to stage 2 blocks
   315 0000013F 5A                      	pop dx		;; restore drive num
   316                                  	
   317                                  	;; ok now we can run either an stage loader, or directly stage 2 (by default it'll be stage 2)
   318 00000140 FF2E[7905]              	jmp far [realaddress(nextstage_seg)]
   319                                  		
   320                                  read_error:
   321 00000144 EBFE                    	jmp $
   322                                  
   323                                  print_msg:                     ; bp:   ptr to msg (in es)
   324 00000146 B80113                         mov ax, 0x1301          ; cx:   msg len
   325 00000149 BB0700                         mov bx, 0x0007          ; dx:   row-col
   326 0000014C CD10                           int 0x10
   327 0000014E C3                             ret
   328                                  
   329                                  print_dot:
   330 0000014F B40E                           mov ah, 0x0e            ; print a dot
   331 00000151 B02E                           mov al, '.'
   332 00000153 31DB                           xor bx, bx
   333 00000155 CD10                           int 0x10
   334 00000157 C3                             ret
   335                                  
   336                                  loading_msg:
   337 00000158 4C6F6164696E67          	db 'Loading'
   338                                  boot_msg:
   339 0000015F 536172746F72697320-     	db 'Sartoris Bootloader 2.0'
   340 00000168 426F6F746C6F616465-
   341 00000171 7220322E30         
   342                                  
   343                                  ;; Data for stage 1.5
   344                                  tries:
   345 00000176 00                      	db 0
   346                                  	
   347                                  nextcopy_seg:
   348 00000177 0000                    	dw 0
   349                                  
   350                                  nextstage_seg:
   351 00000179 0000                    	dw 0
   352 0000017B 0020                    	dw stage2seg16		;; default to stage 2, if a file system loader should be used, this should be replaced by
   353                                  						;; a different address, not colliding with stage 2 segment.
   354                                  
   355                                  ;; let the block list be at a known location on the stage	
   356                                  
   357 0000017D 00<rept>                times (391-($-$$)) db 0x00  	;;(we will leave space for 20 list nodes)
   358                                  
   359                                  ;; now block_list_len is always at location 391 on this stage
   360                                  block_list_len:
   361 00000187 01                      		db 1			;; by default we will only have one entry
   362                                  block_list_start:
   363                                  		;; here we define our default entry
   364                                  		;; starting at lba 2 with a length of (7*128)+2 512 bytes blocks.
   365                                  		istruc blocklist_entry
   366 00000188 02000000                		at blocklist_entry.block, dd 2			;; start coping at sector 2
   367 0000018C 8203                    		at blocklist_entry.length, dw (7*128)+2		;; copy the whole init image (if an os img is greater this should be changed)
   368                                  		iend
   369                                  		
   370                                  ;; complete with 0's 
   371 0000018E 00<rept>                times (512-($-$$)) db 0x00
