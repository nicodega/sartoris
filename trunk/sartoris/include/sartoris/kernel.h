/*  
 *   Sartoris main kernel header                                          
 *   
 *   Copyright (C) 2002, Santiago Bazerque and Nicolas de Galarreta
 *   
 *   sbazerqu@dc.uba.ar                
 *   nicodega@gmail.com
 */

#ifndef _KERNEL_H_
#define _KERNEL_H_

#include <sartoris/types.h>

/* limitations and init params */
#define MAX_ALLOC_LINEAR   0x7000000   /* 112 MB (remember to change stack_windings and int.s debug routine on i386 if this value is modified) */
#define MIN_TASK_OFFSET    MAX_ALLOC_LINEAR

#define MAX_SCA						43    /* max system calls */
#define MAX_TSK						4096  /* max tasks */
#define MAX_THR						16384 /* max concurrent threads of execution */
#define MAX_IRQ						64    /* max irqs */
#define MAX_SMO						65536 /* system-wide */
#define MAX_MSG						65536 /* system-wide */
#define MAX_OPEN_PORTS				(32*MAX_TSK)   /* system-wide */
#define MAX_TSK_OPEN_PORTS			32
#define MAX_MSG_ON_PORT				64 

#define MAX_NESTED_INT 32

#define INIT_TASK_NUM   31   /* INIT_TASK_NUM must NOT be zero                */ 
#define INIT_THREAD_NUM 31   /* (zero is used as pre-init pseudo-task number) */

#ifndef NULL
# define NULL 0
#endif

/* possible task states */
enum task_state { LOADING=0, ALIVE, UNLOADING, DEFUNCT };

/* thread run mode options */
enum usage_mode { PERM_REQ=0, PRIV_LEVEL_ONLY, DISABLED, UNRESTRICTED };

#define MAX_USAGE_MODE  UNRESTRICTED

/* shared-memory object permissions */
#define READ_PERM  2 
#define WRITE_PERM 4

#define SUCCESS    0
#define FAILURE   -1

/* Don't move this include to the top. It uses MAX_THR. */
#ifdef __KERNEL__
#include <kernel-arch.h>
#endif

/* Structures pre definition */
struct c_task_unit;			// this structure comes from containers.h
struct c_thread_unit;		// this structure comes from containers.h
struct port;
struct smo;

/* 
This is an optional access permission structure for threads and ports
which implement the PERM_REQ access mode. 
*/
struct permissions
{
    unsigned int start;  // first thread for which permissions are given.
    unsigned int length; // next to this, must be the bitmap
#ifdef __KERNEL__
    unsigned int *bitmap;
#endif
};

/* main data structures */
struct task 
{
	void *mem_adr;
	unsigned int size;
	int priv_level;

#ifdef __KERNEL__
	char state;         
	char padding[3];
	int thread_count;
	/* 
	Queue  mapping, it binds an open port to a message queue from the 
    message queue pool 
	*/
	struct port *open_ports[MAX_TSK_OPEN_PORTS];
	struct smo *first_smo;
	int smos;
#endif
} __attribute__ ((__packed__));

/*
NOTE: If this struct size is changed, check thread_state on
arch part for i386 for 16 byte alignment.
Size 40 bytes.
*/
struct thread 
{
	int task_num;
	int invoke_mode;
	int invoke_level;
	void *ep;
	void *stack;
    
#ifdef __KERNEL__
    struct permissions run_perms;      // this is a pointer to user space!
    char page_faulted;					/* used to know if we have produced a page fault */
    char padding;
	short last_error;                   // last error (see error.h)
	int trace_task;                     // if -1 no task is allowed to trace this thread. If it's not -1, the specified task can.
#endif
} __attribute__ ((__packed__));

struct page_fault 
{
	int task_id;
	int thread_id;
	void *linear;
	int pg_size;	    // used if our architecture provides multiple page sizes.
	int flags;			// flags for the page fault
};

#define PF_FLAG_NONE   0  // a normal page fault interrupt.
#define PF_FLAG_FREE   1  // a page fault returning a page from the kernel.
#define PF_FLAG_EXT    2  // it was a page fault generated by the thread, but for another task.. not it's task
#define PF_FLAG_PG     4  // a page fault for a kernel page need.
#define PF_FLAG_TRACE  8  // if it's a page fault because of a memory write due to a trace
#define PF_FLAG_PGS(a) ((a << PF_FLAG_PG)+PF_FLAG_PG) // a page fault for the kernel asking for "a" pages

#define PF_FLAG_GET_PGS(f) ((f-PF_FLAG_PG) >> 2) // a page fault for the kernel asking for "a" pages

#ifdef __KERNEL__

void handle_int(int number);

/* a default VALIDATE_PTR: */
#ifndef VALIDATE_PTR
#define VALIDATE_PTR(x) ((unsigned int) (x) < (unsigned int) (GET_PTR(curr_task,tsk))->size)
#endif
/* a default VALIDATE_PTR_TSK: */
#ifndef VALIDATE_PTR_TSK
#define VALIDATE_PTR_TSK(task,x) ((unsigned int) (x) < (unsigned int) (GET_PTR(task,tsk))->size)
#endif
/* A check for unsigned sum overflow */
#ifndef SUMOVERFLOW
#define SUMOVERFLOW(x, y) (((unsigned int)x+(unsigned int)y) < (unsigned int)x || ((unsigned int)x+(unsigned int)y) < (unsigned int)y)
#endif

/* verify that the basic memory layout defines are present */

#ifndef KRN_OFFSET
#error "Architecture does not define the kernel offset in memory (KRN_OFFSET)"
#endif

#ifndef USER_OFFSET
#error "Architecture does not define the offset at which userspace begins (USER_OFFSET)"
#endif

#endif /* __KERNEL__ */

/* these defines can't be moved into PAGING because
   when the files are used from userland kernel-arch.h
   can't be included */
   
/* or can it be included? */
#define PGATT_CACHE_DIS 1
#define PGATT_WRITE_ENA 2
#define PGATT_WRITE_THR 4

#ifdef PAGING

#ifdef __KERNEL__ /* things we only check when compiling the kernel */

#ifndef PG_SIZE
#error "Paging architecture does not define a default page size (PG_SIZE)"
#endif

#ifndef PG_LEVELS
#error "Paging architecture does not define the number of page-indirections (PG_LEVELS)"
#endif

#ifndef IS_PAGE_FAULT
#error "Architecture does not define IS_PAGE_FAULT predicate"
#endif

#endif /* __KERNEL__ */

#endif /* PAGING */

#endif /* _KERNEL_H_ */



