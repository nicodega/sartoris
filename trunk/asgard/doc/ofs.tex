\documentclass[11pt, letterpaper, twoside, english]{book}

%\topmargin  0.25in
%\headheight 0.2in
%\headsep    0.3in
%\textheight 8.5in
%\textwidth  6.0in
%\footskip   0.7in

\setlength{\parskip}{1.5ex}

\usepackage[activeacute]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsfonts, amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}%
\setcounter{MaxMatrixCols}{30}
\pagestyle{plain}

\begin{document}

\frontmatter
\thispagestyle{empty}

\vspace*{2.5cm}
\noindent\makebox{\begin{minipage}{\textwidth}{
\flushright \Huge Obsession File System \\

}


\noindent\rule{\textwidth}{4pt}

\noindent\flushright { \large Design concepts and implementation of the service. }

\end{minipage}
}

\vspace{10cm}
\noindent\makebox{\begin{minipage}{\textwidth}{
\flushright by Santiago Bazerque, Nicol\'as de Galarreta \\
and Mat\'ias Brunstein Macri\\[1.5ex]
for Sartoris version 0.9, \today.

}
\end{minipage}
}

\newpage
\thispagestyle{empty}
\cleardoublepage

\chapter{Abstract}

This document provides a definition on how File System services should be
managed on Phantom Operating System.

For better reading this document has been split on tree main chapters:

\begin{enumerate}
\item[]\textbf{Inter-File system communication Standardization.} Provides an overview of the protocols created in order to provide a common way to interact with file system services and devices.\item[]\textbf{The OFS File System model.} Describes the OFS File System disk structure.
\item[]\textbf{The OFS Service.} Details on the implemented OFS Service.
\end{enumerate}

\bigskip

Each section describes a different aspect taken on account when the Sioux File
system was being devised.

\tableofcontents

\mainmatter

\chapter{Inter-File System Communication Standardization}\label{protocols}

\section{Introduction}

Through time, lots of File System formats have been devised, from FAT to EXT2,
this introduces a big problem when designing file system services because it's
impossible to support them all together. As Phantom is a service based Operating
System this also introduces a communication problem, because each service is
not forced to use a common protocol. In order to bring a little coherence to
this possible chaos a set of protocols was deviced for File System Services and Devices.

This protocols are:
\begin{enumerate}
\item[]\textbf{STDFSS} Provides a common protocol for File System Services, allowing most common operations.
\item[]\textbf{STDDEV} Provides a common protocol for Device Driver Services. This standard is meant to provide a way to get information about used protocols and allows using \textsf{ioctl()} commands.
\item[]\textbf{STD BLOCK DEV} Defines a set of common messages issued to block devices like read, write, etc.
\item[]\textbf{STD CHAR DEV} Defines a set of common messages issued to character devices like read, write, etc.
\item[]\textbf{STD SERVICE} This standard was deviced while creating the OFS Service, but applies for all services. It specifies a set of common messages for system services. 
\end{enumerate}

\bigskip

In the following sub-sections we'll dig deeper on the details for the protocols specified.

\section{Standard Service Protocol}

\subsection{Purpose of the interface}

The standard Service protocol, is meant to be implemented by all services running on Phantom. It's main purposes are to provide the Process Manager service with a common interface for Shutting down, Freezing an waking up processes, as well as providing a common message interface for different protocol implementations.\\

This interface must always be available through port \textbf{0} of the service.\\

\subsection{Messages}

Messages defined by this standard are:

\begin{enumerate}
\item[]\textbf{STDSERVICE\_DIE}\\ This command will be sent by the Process manager, indicating the current service is going for shutdown. When receiving this message the service should try to free system resources, and cancel any operations it might be performing. When the service is ready for shutdown a response message must be sent to the Process Manager.\\ This command can return a failure response.
\item[]\textbf{STDSERVICE\_FORCEDIE}\\ This command is very similar to STDSERVICE\_DIE, except for the fact that the service \textbf{must} shutdown no matter what. Response sent to the process Manager will be ignored and the service will be shut down even if command failed.
\item[]\textbf{STDSERVICE\_PREPAREFORSLEEP}\\ This message is meant for preparing the service for a system freeze. When issued by the Process Manager, it means the system will be put to hibernation. Al IO should be stopped and the service should remain in a passive state until STDSERVICE\_WAKEUP is issued.\\ When the service has finished setting up for sleep, a response message will be issued.
\item[]\textbf{STDSERVICE\_WAKEUP}\\ When the system restores from SLEEP, this command will be sent to services indicating they may continue operating normally.
\item[]\textbf{STDSERVICE\_QUERYINTERFACE}\\ As messages provided by the underlying Microkernel do not provide a message format, but a 128bit messaging system, protocols for inter task communication must be devised. As services begin to provide more functionality, different protocol versions will be created. This wouldn't be a problem if there where a few protocols implemented by services at specified ports. But real life has probed this is not the case. The same protocols can be implemented by different services, and when protocol ports are hardcoded, things start to get a little bit difficult to maintain.\\ In order to bring light to the protocol issue, this command allows any given service to find out if an specific protocol is implemented by a service, and on which port those commands will be processed.\\
Protocols will have a unique UIID (Unique Interface IDentifier) and a version.
\end{enumerate}

\bigskip

\section{Standard File System Protocol}

\subsection{Purpose of the interface}

The standard file system protocol is probably the biggest protocol we've created. And it's likely to grow even more.
This set of messages provide a way to perform common file\-system actions, like opening a file, reading, writing, etc.

\subsection{Messages}

STDFSS (Standard File System Service) protocol messages share a common basic structure:

\begin{verbatim}
struct stdfss_cmd{
  unsigned short command;
  unsigned char thr_id;
  unsigned char specific0;
  unsigned int  specific1;
  unsigned int  specific2;
  unsigned short specific3;
  unsigned short ret_port;
};
\end{verbatim}

Where \verb|command| will contain the required command, \verb|thr_id| holds a number which will be copied onto the response message, \verb|ret_port| will be the port number on which the sender expects the response and \verb|specific0| to \verb|specific3| may be different on each command.

\noindent{Response messages also share a common basic structure:}

\begin{verbatim}
struct stdfss_res{
  unsigned short command;
  unsigned char thr_id;
  unsigned char padding0;
  unsigned int ret;
  unsigned int param1;
  unsigned int param2;
};
\end{verbatim}

The fields \verb|command| and \verb|thr_id| will be copied as they where on the command. \verb|ret| will hold an error code as defined in the Return Error Codes sub section.

All command messages defined on this protocol are:

\begin{enumerate}
\item[]\textbf{STDFSS\_VERSION}\\ This command is only meant to provide the STDFSS version implemented by this service. Return structure will have the form:

\begin{verbatim}
struct stdfss_ver_res{
  unsigned short command;
  unsigned char thr_id;
  unsigned char padding00;
  unsigned int  ret;    
  unsigned int  padding1;
  unsigned int  ver;
};
\end{verbatim}

Where the field \verb|ver| will contain an integer value indicating the current protocol version.

\item[]\textbf{STDFSS\_INIT}\\ When an STDFSS service is loaded, it will be told which task implements the device driver for the root directory (specified by the fields \verb|deviceid|), it's logic device id\footnote{Logic device id's are meant to allow a single device driver service to manage multiple devices at the same time.} (\verb|logic_deviceid|) and the mount path (meaning all requests to this file system will have the provided path as a prefix) in an \textbf{smo} object.\\
It's important to notice this command should be the first command issued through this protocol. all other commands (with the exception of STDFSS\_VERSION) will fail if the service has not been initialized.
\item[]\textbf{STDFSS\_MOUNT}\\ This command provides the means to \textsf{mount} a given block device with a compatible file system onto the service directory tree. Device information will be taken from an specified device file and will be mounted on a given path.\\ When mounting a device, it's possible to specify a \textbf{mount mode} using the following defines:\\

STDFSS\_MOUNTMODE\_DEDICATED\\
STDFSS\_MOUNTMODE\_READ\\
STDFSS\_MOUNTMODE\_WRITE\\

This values can be ORed together.
When mounting a device as DEDICATED it'll be taken exclusively by the FS Service. Had it been already gotten by any other services, mount will fail.\\
If an attempt is made to mount a device on a path which is not a directory, or the directory is not empty the command will fail.
\item[]\textbf{STDFSS\_UMOUNT}\\ By providing a path previously used on a mount command, the service will \textsf{unmount} it, removing the device file system from it's directory tree.\\
If UMOUNT path was not mounted on the service, or mounting had failed, this command will fail.\\
It's also important to notice that if there are opened files on the service the UMOUNT operation will not be performed.
\item[]\textbf{STDFSS\_OPEN}\\ This is one of the most important commands on the STDFSS protocol. This command will allow a task to open a file, a directory or a device file for performing operations on it. \\The command message structure is:\\

\begin{verbatim}
struct stdfss_open{
  unsigned short command;
  unsigned char thr_id;
  unsigned char padding0;
  unsigned int  file_path;
  unsigned int  open_mode;
  unsigned short flags;
  unsigned short ret_port;
};
\end{verbatim}
 
When opening a file three parameters must be supplied:\\
\\
\textbf{file\_path}: An smo containing the full absolute path to the file being opened.\\
\textbf{open\_mode}: One or more (ORed) of the following defines:\\
\begin{enumerate}
\item[] \textbf{STDFSS\_FILEMODE\_READ} Request to perform read operations on the file.\\
\item[] \textbf{STDFSS\_FILEMODE\_WRITE} Request to perform write operations on the file.\\
\item[] \textbf{STDFSS\_FILEMODE\_APPEND} Request to perform append operations on the file.\\
\item[] \textbf{STDFSS\_FILEMODE\_EXCLUSIVE} Request the file to be opened in exclusive. This means no other tasks will be able to open it until the sender task closes the file. Should any task have the file open, the command will fail.\\
\end{enumerate}

WRITE and APPEND modes cannot be specified at the same time for a given file.\\
\\
\textbf{flags}: Flags can be one or more (ORed) of the following defines:\\
\begin{enumerate}
\item[] \textbf{STDFSS\_OPEN\_WRITEBUFFERED} If specified, device operations might get delayed. If not, operations will be persisted immediately.\\
\item[] \textbf{STDFSS\_FILEMODE\_MUSTEXIST} When this flag is specified the file must exist in order to open it. If this flag is not specified, and the provided file path exists but the file itself does not, the file will be created and the command will succeed.\\
\end{enumerate}
 
The response command message structure is defined as follows:

\begin{verbatim}
struct stdfss_open_res{
  unsigned short command;
  unsigned char thr_id;
  unsigned char padding0;
  unsigned int  ret;
  unsigned int  padding;
  unsigned int  file_id;
};
\end{verbatim}
 
If the command completed successfully, \verb|file_id| will hold a number used by the service to identify the opened file by the sender task. This ID will be the one supplied when issuing the following commands: \textbf{STDFSS\_CLOSE}, \textbf{STDFSS\_READ}, \textbf{STDFSS\_WRITE}, \textbf{STDFSS\_SEEK}, \textbf{STDFSS\_TELL} and \textbf{STDFSS\_FLUSH}.
 
\item[]\textbf{STDFSS\_CLOSE}\\ When a task has finished using an opened file, a CLOSE command should be issued. When closing, the sender task will no longer be able to perform operations on the opened file. If the file was opened on a buffered fashion, buffers will be flushed, persisting file changes.
\item[]\textbf{STDFSS\_READ}\\ This command will read as many bytes as specified by the field \verb|count| from an opened file. Reading will begin at the current cursor position. if the file was not opened specifying STDFSS\_FILEMODE\_READ mode, the command will fail.
\item[]\textbf{STDFSS\_WRITE}\\ This command will write as many bytes as specified by the field \verb|count| from an opened file. If the file was opened specifying STDFSS\_FILEMODE\_WRITE mode, writing will begin at the current cursor position. If the file was opened specifying STDFSS\_FILEMODE\_APPEND mode, writing will always begin at the end of the file, and the read/write cursor will be placed at the end.
\item[]\textbf{STDFSS\_PUTC}\\ This command will write a single character onto an opened file. The character will be specified by the \verb|c| field, on the command message structure.
\item[]\textbf{STDFSS\_PUTS}\\ This command will write a string onto the specified opened file. The Service will write until a \verb|'\0'| character is found or it wrote as many bytes as specified on the \verb|count| field.
\item[]\textbf{STDFSS\_GETC}\\ This command will read a single character from an opened file. The character read will be returned on the \verb|c| field, in the command response message structure.
\item[]\textbf{STDFSS\_GETS}\\ This command will read a string from the specified opened file. The Service will read until a \verb|'\n'| character is found or it read as many bytes as specified on the \verb|count| field subtracting 1. The provided buffer is guarantied to end with a \verb|'\0'| character.
\item[]\textbf{STDFSS\_SEEK}\\ This command will move the read/write cursor position relative to the specified origin. The \verb|origin| field might be one of the following:\\
\begin{enumerate}
\item[] \textbf{STDFSS\_SEEK\_SET} Cursor will be set to the \verb|position| field value. 
\item[] \textbf{STDFSS\_SEEK\_CUR} Cursor will be set by adding the current cursor value to that, specified in the \verb|position| field.
\item[] \textbf{STDFSS\_SEEK\_END} Cursor will be set considering the \verb|position| field as a displacement from the end of the file.
\end{enumerate}
\item[]\textbf{STDFSS\_TELL}\\ This command returns the position of the read/write cursor for the specified opened file.
\item[]\textbf{STDFSS\_FLUSH}\\ This command will force the service to preserve any changes performed on the file so far. If the file was no opened specifying the flag \verb|STDFSS\_OPEN\_WRITEBUFFERED| this command should do nothing.
\item[]\textbf{STDFSS\_LINK}\\ This command will allow file, hard linking. Hard Linking will only be performed between files on the same logic device.
\item[]\textbf{STDFSS\_MKDIR}\\ MKDIR command will create a directory at the specified path.
\item[]\textbf{STDFSS\_MKDEVICE}\\ MKDEVICE will create a device file at the specified file path. The path should exist and if the file already exists, the command will fail to execute.
\item[]\textbf{STDFSS\_CHANGEATT}\\ CHANGEATT allows changing the properties of a file. Properties that can be changed are defined by the following flags:\\
\begin{enumerate}
\item[] \textbf{STDFSS\_ATT\_READONLY} If set this flag will give the file the Read Only property, making it impossible to open the file for writing. 
\item[] \textbf{STDFSS\_ATT\_HIDDEN} If set, this file will marked with the hidden flag. This flag has no meaning to the File System service, but to the process listing files.
\item[] \textbf{STDFSS\_ATT\_ENCRYPTED} If this flag is set, the file will be encrypted on disc. This feature may not be available on all File System Services.
\end{enumerate}
\item[]\textbf{STDFSS\_DELETE}\\ This command will remove the specified file/dir. Should the file/dir be opened by a task or if it's a directory contain any files, the command will fail. 
\item[]\textbf{STDFSS\_FILEINFO}\\ This command will fill a structure using the provided SMO. The structure provided will be specified by the \verb|file\_info\_id| field of the command. This structure id will change as different versions for the \textbf{STDFSS} protocol are devised. The calling task must set this field to \verb|FILEINFO\_ID| define, specified in \verb|stdfss.h|. STDFSS current implementation provides the following file info structure:\\
\begin{verbatim}
struct file_info0
{
  int file_type;
  unsigned long long creation_date;
  unsigned long long modification_date;
  unsigned long long file_size;
  int flags;
  int dir_entries;
  int protection;     /* protection */
  int hard_links;
  int owner_id;
  int owner_group_id;
  int device_service_id;
  int logic_device_id;
};
\end{verbatim}
If the specified path represents a file, all fields but \verb|dir_entries|, \verb|device_service_id| and \verb|logic_device_id| will be filled.\\
If the specified path represents a directory, upon successful execution, the field \verb|dir_entries| will hold the amount of files the directory has.\\
If the specified path represents a device, \verb|device_service_id| and \verb|logic_device_id| fields will contain the device driver service task id and logic device id.\\
All other fields, will always be filled with the specified file information.
\item[]\textbf{STDFSS\_EXISTS}\\ The exists command, checks whether a file exists or not, and returns the file type. 
\item[]\textbf{STDFSS\_IOCTL}\\ \textbf{STDFSS} Protocol, provides a unified way to send specific device commands through the  \textbf{IOCTRL} command. This command will only be executed when the device has been opened by issuing \textbf{STDFSS\_OPEN}. The field \verb|request| should specify a device IOCTRL request command\footnote{IOCTRL commands will be service specific, meaning each device driver service will have proprietary IOCTRL commands.}. By using the \verb|param| field the caller will provide IOCTRL request parameters.
\item[]\textbf{STDFSS\_FORWARD}\\ This command is meant to be used between \textbf{STDFSS} services, when multiple services are being used. It provides a way for a service to forward all other \textbf{STDFSS} messages.
\end{enumerate}

\subsection{Multiple FS services}

Currently, support for multiple File System Services is being developed. The main idea is to name a given service as the \textbf{Parent}, creating a Service hierarchy. All FS commands should then be executed through the Master service, Except commands which work with opened files.\\
The Master Service would maintain the mounted tree, and will forward messages to the slave Services.\\
Although this sounds pretty much as a simple protocol, there are still some difficulties related to the \textbf{MOUNT} and \textbf{UMOUNT} commands, on which we are working on.

\subsection{Return Error Codes}

Error codes defined for the STDFSS protocol are:
\begin{enumerate}
\item[]\textbf{STDFSSERR\_OK}
\item[]\textbf{STDFSSERR\_DEVICE\_NOT\_MOUNTED}
\item[]\textbf{STDFSSERR\_PATH\_ALREADY\_MOUNTED}
\item[]\textbf{STDFSSERR\_DEVICE\_ALREADY\_MOUNTED}
\item[]\textbf{STDFSSERR\_DEVICE\_FILE\_NOT\_FOUND}
\item[]\textbf{STDFSSERR\_SERVICE\_NOT\_INITIALIZED}
\item[]\textbf{STDFSSERR\_NOT\_ENOUGH\_MEM}
\item[]\textbf{STDFSSERR\_COULD\_NOT\_ACCESS\_DEVICE}
\item[]\textbf{STDFSSERR\_STDFS\_SERVICE\_SHUTDOWN}
\item[]\textbf{STDFSSERR\_SERVICE\_ALREADY\_INITIALIZED}
\item[]\textbf{STDFSSERR\_INTERFACE\_NOT\_FOUND}
\item[]\textbf{STDFSSERR\_DEVICE\_ERROR}
\item[]\textbf{STDFSSERR\_FORMAT\_NOT\_SUPPORTED}
\item[]\textbf{STDFSSERR\_INVALID\_COMMAND}
\item[]\textbf{STDFSSERR\_INVALID\_COMMAND\_PARAMS}
\item[]\textbf{STDFSSERR\_EOF}
\item[]\textbf{STDFSSERR\_FATAL}
\item[]\textbf{STDFSSERR\_NOT\_FOUND}
\item[]\textbf{STDFSSERR\_FILE\_INUSE}
\item[]\textbf{STDFSSERR\_FILE\_DOESNOTEXIST}
\item[]\textbf{STDFSSERR\_FILE\_INVALIDOPERATION}
\item[]\textbf{STDFSSERR\_FILE\_DIRNOTEMPTY}
\item[]\textbf{STDFSSERR\_FILE\_NOTOPEN}
\item[]\textbf{STDFSSERR\_TOOMANY\_FILESOPEN}
\item[]\textbf{STDFSSERR\_DEVICE\_MOUNTED}
\item[]\textbf{STDFSSERR\_PATH\_INUSE}
\item[]\textbf{STDFSSERR\_BAD\_DEVICE\_FILE}
\item[]\textbf{STDFSSERR\_DEVICE\_INUSE}
\item[]\textbf{STDFSSERR\_FILE\_EXISTS}
\item[]\textbf{STDFSSERR\_DEVICE\_NOTSUPPORTED}
\item[]\textbf{STDFSSERR\_NOT\_DEVICEFILE}
\item[]\textbf{STDFSSERR\_NOT\_SUPPORTED}
\item[]\textbf{STDFSSERR\_NO\_PRIVILEGES}
\item[]\textbf{STDFSSERR\_SMO\_ERROR}
\item[]\textbf{STDFSSERR\_COMMAND\_NOTSUPPORTED}	
\end{enumerate}

\bigskip

\section{Standard Device Protocol}

\bigskip

\subsection{Purpose of the interface}

As File System Services will have to access devices for performing operations on them (from reading/writing to ioctrl commands) and some of this operations may be exclusive, Device Driver Services should provide a common interface for providing device ownership commands.\\
This protocol must be implemented by every device driver on the system.

\subsection{Devices ownership}

As it was stated before, some Services, might require exclusive access to certain devices. In order to provide this functionality, the \textbf{STDDEV} protocol was created.\\
This protocol provides a command's set, allowing a given service to get exclusive or non exclusive access to the Device Driver logic devices.\footnote{Logic devices are a way to allow a single service to manage multiple physical or logic devices.}\\
This commands are:\\
\begin{enumerate}
\item[]\textbf{STDDEV\_GET\_DEVICE} \\ This command will attempt to get the logic device in a non-exclusive way. Should any other service have the Device Driver Logic Device in an \textbf{exclusive} fashion, this command will fail. If the command succeeds, the sender service is guarranted to execute specific protocol commands on the device, targeting the owned Logic Device, and upon completion it should free the Device Driver Logic Device.
\item[]\textbf{STDDEV\_GET\_DEVICEX} \\ This command will try to get exclusive Device Driver Logic Device ownership. If the command succeeds the sender Service is guaranteed to have exclusive access to the Logic Device, meaning no other services can issue commands on the Logic Device until it´s freed.
\item[]\textbf{STDDEV\_FREE\_DEVICE} \\ By issuing an \textbf{STDDEV\_FREE\_DEVICE} command, the sender service tells the driver, it will no longer use the Logic Device. If the service had never got the device, the command might succeed or fail, depending on the Device Driver Service implementation.
\end{enumerate}

It's important to notice that if a given service attempts to execute other protocol commands while not holding ownership of the device driver, the command will fail immediately. This means that if a Service wishes to execute commands on a Device Driver Service, it will first have to \textbf{GET} the driver. After command execution is finished or upon service shutdown, all devices should be freed.\\
All ownership commands will be valid not only considering the Device Driver Service but by Logic Device.

\subsection{Device Information Commands}

Along side with ownership commands, all devices will be able to inform a given service which device type it is they can handle. This type can be obtained through the \textbf{STDDEV\_GET\_DEVICETYPE} command.\\
The device type response message will contag the type on the \verb|dev_type| field, being one of the following defines:\\
\begin{enumerate}
\item[]\textbf{STDDEV\_BLOCK} \\ When this type is returned, the device implements the \textbf{Standard Block Device Protocol} interface. The return message for this devices will also fill \verb|block_size| field with the device block size in bytes.
\item[]\textbf{STDDEV\_CHAR} \\ When this type is returned, the device implements the \textbf{Standard Character Device Protocol} interface.
\item[]\textbf{STDDEV\_UNDEFINED} \\ Should this be the type returned, no standard protocol is implemented by the Device Driver.
\end{enumerate}

\subsection{IOCTRL Commands}

IO Control (IOCTRL) commands are a unified way for executing Device Driver specific commands, not defined on the standard interfaces.\\
Each service might provide as many IOCTRL commands as it wishes to, provided they define a request identifier and either they use a single \verb|int| parameter sent through the \verb|param| field, or a parameters structure. If the second if the preferred choice, the \verb|param| field should be a valid \textbf{SMO} object identifier.

\bigskip

\section{Standard Block Device Protocol}

\bigskip

\subsection{Purpose of the interface}

File system services need a standard way to issue commands for reading/writing on Device Driver Services Logic Devices. This Protocol, provides an standardized way to perform this actions on Block devices.\\
Before issuing any of the interface commands, the service should get Logic Device ownership, using the Standard Device Protocol.\\ All commands but \textbf{BLOCK\_STDDEV\_INFO} will fail, if ownership was not granted.

\subsection{Commands}

Protocol specified commands are:\\

\begin{enumerate}
\item[]\textbf{BLOCK\_STDDEV\_READ} \\ This command will read the contents of a full sector at \textbf{LBA} position \verb|pos| on the Logic Device, onto the provided smo buffer.
\item[]\textbf{BLOCK\_STDDEV\_WRITE} \\ This command will write the contents of a full sector at \textbf{LBA} position \verb|pos| on the Logic Device, from the provided smo buffer.
\item[]\textbf{BLOCK\_STDDEV\_READM} \\ This command will read the contents of as many full sectors as specified on the field \verb|count| starting at \textbf{LBA} position \verb|pos| on the Logic Device, onto the provided smo buffer.
\item[]\textbf{BLOCK\_STDDEV\_WRITEM} \\ This command will write the contents of as many full sectors as specified on the field \verb|count| starting at \textbf{LBA} position \verb|pos| on the Logic Device, from the provided smo buffer.
\item[]\textbf{BLOCK\_STDDEV\_INFO} \\ This command will return device information. Upon success the service will write information on the structure shared by the \verb|devinf_smo| field. Structure format used will depend on \verb|devinf_id|. This field should be set to \textbf{DEVICEINFO\_ID}. The current id, will fill the following structure:\\
\begin{verbatim}
struct blockdev_info0
{
  unsigned long long media_size;
  unsigned long max_lba;
};
\end{verbatim}
\end{enumerate}

\bigskip

\section{Standard Character Device Protocol}

\subsection{Purpose of the interface}

Even though File System Services wont't access character devices as a mounted device, they might access it as a file. This leads to this standard, which provides a way to read and write from a Character device.\\
Character devices will be seen as a stream of bytes. 

\subsection{Commands}

Protocols commands can be summarized as follows:\\

\begin{enumerate}
\item[]\textbf{CHAR\_STDDEV\_READ} \\ This command will read characters from the specified Logic Device. If reading is not delimited and blocking, the device will return when exactly \verb|byte_count| characters where read. If reading without delimiter in a non blocking way, the driver will attempt to read as many bytes as possible up to \verb|byte_count|, returning immediately even if no data was available. If a delimiter is used, instead of using \verb|byte_count|, the driver will read until the delimiter character is entered or \verb|byte_count| were read.
\item[]\textbf{CHAR\_STDDEV\_READC} \\ This command will read one character from the device. If blocking read is issued the command won't return until the character is available. If non-blocking read is issued if there is no character, the device will return failure. The character read will be returned on the \verb|c| field of the response message.
\item[]\textbf{CHAR\_STDDEV\_WRITE} \\ This command will write characters to the specified Logic Device. If writing is not delimited, the device will write exactly \verb|byte_count| characters. If a delimiter is used, instead of writing \verb|byte_count|, the driver will write until the delimiter character is found or \verb|byte_count| were written.
\item[]\textbf{CHAR\_STDDEV\_WRITEC} \\ This command will write exactly one character, specified by the \verb|c| field.
\item[]\textbf{CHAR\_STDDEV\_SEEK} \\ Seek commands will move the device read/write position. Depending on device implementation this operation might fail under certain conditions. Cursor will be moved from the origin specified by using the \verb|flags| field.
\item[]\textbf{CHAR\_STDDEV\_TELL} \\ This command will return the current read/write cursor position for a given Logic Device.
\item[]\textbf{CHAR\_STDDEV\_RESET} \\ This command will reset the Logic Device.
\end{enumerate}

When issuing READ, READC, WRITE or WRITEC commands, the \verb|flags| field must be set to one or more (ORed) of this defines:\\
\begin{enumerate}
\item[]\textbf{CHAR\_STDDEV\_READFLAG\_ECHO} \\ If specified, this flag will tell the Device Driver to echo the characters read o written on screen. This flag is actually only useful on devices which are able to echo characters.
\item[]\textbf{CHAR\_STDDEV\_READFLAG\_BLOCKING} \\ If specified while reading or writing this flag tells the Device Driver to treat the command as blocking.
\item[]\textbf{CHAR\_STDDEV\_READFLAG\_DELIMITED} \\ If specified this flag tells the Device Driver to consider the delimiter character on read/write operations.
\item[]\textbf{CHAR\_STDDEV\_READFLAG\_PASSMEM} \\ When this flag is specified, the Device Driver service will perform a \verb|pass_mem| operation on the smo sent for reading/writing, specifying the sender id as the destination task id.
\end{enumerate}

\bigskip

\chapter{OFS\ File system Model}

\bigskip
\section{Introduction}

The OFS (Obsession File System) structure, aims to provide an adecuate
structure for file management. Some of the main aspects considered while the
File System was designed include:

\begin{enumerate}
\item[]\textbf{Reliability}
\item[]\textbf{Simplicity}
\item[]\textbf{Extensibility}
\end{enumerate}

The OFS is not only designed to be a File System, but also to provide a base
for more complex File System structures. Disk Layout provided on this document
intends to provide an extensible structure able to provide security,
encryption, and many more capabilities, as well as a basic File System like
FAT/FAT32 would be.

Though the specification is very flexible, it's important to notice that some
decisions were made based on the operating system it will operate within.

\section{Disk Layout}

An Obsession File System Disk will have the following structure:

(Brackets [] indicate this section may not be present in some implementations
of the OFS File System)

\begin{center}
\begin{tabular}{c|c|c|c|c}
OFST & [METADATA] & GROUP$_1$ & ... & GROUP$_n$
\end{tabular}
\end{center}

\subsection{OFST}

This structure contains essential info on the OFS of the partition.\\

\begin{sf}

\noindent  struct OFST\{\\
\indent      unsigned int mount\_count;\\
\indent\indent       /*Indicates how many times the disk has been mounted.\\
\indent\indent       (This could be used to detect possible errors at boot time)*/\\
\indent      unsigned int block\_size;\\
\indent\indent       /*Size of the blocks used on the groups.*/\\
\indent      unsigned int first\_group;\\
\indent\indent       /*Offset of the first group on the partition.*/\\
\indent      unsigned int ptrs\_on\_node;\\
\indent      unsigned int blocks\_per\_group;\\
\indent      unsigned int nodes\_per\_group;\\
\indent      unsigned int group\_count;\\
\indent\indent       /*Number of groups on the device.*/\\
\indent      unsigned int MetaData;\\
\indent\indent      /*The OFST structure may contain metadata following\\
\indent\indent       this structure. This variable indicated the ID or TYPE of\\
\indent\indent       this Options structure. If 0 it means no Options are present.\\
\indent\indent        (could be used for permissions, encryption, etc)*/\\
\indent      unsigned int Magic\_number;\\
\indent\indent       /*just to keep up with tradition :-)*/\\
\noindent   \};\\
 
\end{sf}

\subsection{Groups}

OFS Groups hold nodes and blocks. A node is a structure used to describe a
given file on the system, while blocks contain the actual data. Groups where
introduced to this specification because of the following reasons:\\

\begin{enumerate}
\item[]They increase the locality of the data on disk. (if the OFS Service
implementation implements this functionality)
\item[]If sectors on the disk got bad, splitting the node/blocks table into pieces
will provide a better chance of recovering files.
\end{enumerate}

It's important to notice that a given file may be spread all over the disc in
different groups. Later it'll be seen nodes can reference nodes or blocks in
other groups. Despite of this, it's highly recommended (because of the above
reasons) for files to be kept in the same group whenever possible.

\bigskip

Each Group is structured internally as follows.

\begin{center}
\begin{tabular}{c|c|c|c|c|c}
GH & [METADATA] & NODES BITMAP & BLOCKS BITMAP & NODE TABLE & BLOCK TABLE
\end{tabular}
\end{center}

\subsubsection{Group Header}

This structure contains information essential to access group information like
table positions, etc.\\

\begin{sf}

\noindent struct GH\{\\
\indent       unsigned int group\_id;\\
\indent\indent        /*The position of the group. (0..GROUPS\_COUNT-1)*/\\
\indent       unsigned int blocks\_per\_group; // same as OFST\\
\indent       unsigned int nodes\_per\_group; // same as OFST\\
\indent       unsigned int nodes\_bitmap\_offset;\\
\indent       unsigned int blocks\_bitmap\_offset;\\
\indent       unsigned int nodes\_table\_offset;\\
\indent       unsigned int blocks\_offset;\\
\indent       unsigned int group\_size;// same on all groups\\
\indent       unsigned int meta\_data\_size;\\
\indent       unsigned int meta\_data;\\
\indent\indent        /*If zero, it means there are no options. If nonzero it identifies\\
\indent\indent         the options structure that follows.*/\\
\noindent\};

\end{sf}

\subsubsection{NODES/BLOCKS Bitmap}

This bitmaps indicate whether a given Node or block is free (0) or used (1)

\subsubsection{Node Table}

This is where all the nodes are kept. The amount of nodes being kept per-group is defined here, but it can be grater or lower. Standard OFS system groups will have as many nodes as blocks on the group. (or more nodes than blocks)

\subsubsection{Block Table}

Blocks provide the available space in the system. The size of each block is specified in the OFST.

\subsection{Nodes}

Nodes are used to describe a file structure and the blocks it uses. Each node will point to a set of blocks which make up the whole file. Should a single node not be enough for holding addresses for all the file blocks, a second node can be used, and a
third, and so on.\\

Files can belong to different classes:\\

\begin{enumerate}
\item[]\textbf{Props} Defines properties for other files. (like permissions, etc).
\item[]\textbf{Dev} Defines a device file. (See Device Files).
\item[]\textbf{Dir} Defines a directory file (See Directory Structure).
\item[]\textbf{File} A common File.
\item[]\textbf{Child} A child node of a file/dev/dir.
\end{enumerate}

Structure of a node is as follows:

\begin{sf}
\noindent     struct node\{\\
\indent       unsigned int type;\\
\indent\indent        /*This field will indicate whether the node identifies a file,\\
\indent\indent        a dir or anything else...\\
\indent\indent         xxxxxxxx xxxxxxxx xxxxxxxx xxx|deleted|props|dev|dir|file\\
\indent\indent        (props files shouldn't be treated as normal files)*/\\
\indent       unsigned long long file\_size;\\
\indent\indent        /*in bytes;*/\\
\indent       unsigned int link\_count;\\
\indent\indent        /* used for garbage collection */
\indent       unsigned long long creation\_date;\\
\indent       unsigned long long modification\_date;\\
\indent       unsigned int MetaData;\\
\indent\indent        /*A node id of a properties file. (this should change if we\\
\indent\indent          have a few amount of props, or perhaps a same property file\\
\indent\indent          could be used on all files appending some sort of indexing by\\
\indent\indent          node :) ). If zero, the file has no special props.*/\\
\indent       unsigned int blocks[PTRS\_ON\_NODE];\\
\indent        /*LBA address of blocks of the node. (NOTE: blocks could be on other groups)*/\\
\indent       unsigned int next\_node;\\
\indent\indent        /*if the file/dir/.. has more blocks than PTRS\_ON\_NODE this will\\
\indent\indent          be nonzero and will contain the LBA address of the next node.\\
\indent\indent          (the next node will contain the same node info except for the block\\
\indent\indent          array values)*/\\
\noindent    \};\\
\end{sf}

\emph{NOTE: PTRS\_ON\_NODE should be the same as the value on OFST. A node size MUST be smaller or equal to 512 bytes.}

\subsection{Device Files}

When nodes are marked as Device Files, they'll describe the structure of a file containing information about a given device, necessary to access it.

\noindent{The Device File structure is as follows:}

\begin{verbatim}
int LOGIC DEVICE ID: internal ID on the service (4B)
int SERVICE NAME SIZE (4B)
char SERVICE NAME[]: name of the device driver (zero terminated string)
\end{verbatim}

Device files must only use block[0] of the node. Service name will have to be 4088 bytes in length counting the ending '$\backslash$0'

Using these values, it's possible for an OFS Service implementation or a device manager to find and (using stddev protocol) access the device.\\

\textbf{NOTE}: It's strongly recommended the system to contain only ONE\ device file for each device. (Hard links could be greater than one, but only one node should exist)

\subsection{Directories}

In order to provide a directory structure, directories are kept in special files called Directory Files (yeah, we are really really creative folks!). File names and location on the directory structure depends only on the content of these files.\\

As in many widely used operating systems (like Linux, FreeBSD, etc), the directory structure of the OFS File System starts with a \"root\" directory and has a Tree-like shape. \\

$root$\\
\indent $usr$\\
\indent\indent $dir1$\\
\indent\indent $dir2$\\
\indent $dev$\\
\indent $etc$\\

\bigskip

\emph{IMPORTANT: The root Directory File node will be the first node on the first group.}

Directory Files are built up by a series of consecutive Directory entries.\\

Each entry has the following format:\\

\begin{center}
\begin{tabular}{c|c|c|c|c}
RECORD LEN In Bytes (4B) & NODEID (4B) & NAME LEN (4B) & FLAGS (4B) & NAME
\end{tabular}
\end{center}

\textbf{FLAGS}: xxxxx$\vert$hidden$\vert$read only$\vert$deleted

\bigskip

\emph{NOTE: name length must not include the ending '$\backslash$0' character }

Files will be given a name, by creating a Directory Entry pointing to it's node.

\subsection{Hard Links}

As Files have a name only due to their existence on directory files, it's possible to create "hard links" by creating entries on different directories for the same file. That way the file "/usr/file1" may point to the same node than "/home/file2".

\bigskip

\chapter{OFS Service}

\section{Introduction}

The OFS Service provides access to devices using the OFS Disk Layout.

OFS Devices must comply to these settings:\\
\begin{enumerate}
\item[]Block size must be 4K
\item[]File Names on directories must be below or equal to 4080
\end{enumerate}

The service uses the Standard Protocols specified in section \ref{protocols} for communication with devices and command processing. This service was designed to provide multiple command execution up to a predefined number of concurrent jobs thus Devices may be executing more than one FS command at the same time.\\
As this is the very first version of the service, privileges management won't be considered.\\
The OFS Service can be split into three different sections. The Service Main Thread, where service initialization is performed, \textbf{STDFSS} commands are enqueued for processing and responses will be processed and The Working Processes, where commands will be executed.

\section{Service Main Thread}

Lets take a closer look at the main loop for the service. The main loop is defined on the file \verb|ofsservice.c| and it's tasks are performed by the function \verb|ofs_main()|. This function is structured as follows:\\
\begin{enumerate}
\item[]Global variables initialization
\item[]Directory Registration as \verb|fs/default| service.\footnote{This might change when multiple FS Services are taken on account.}
\item[]Port opening.
\item[]The Main Processing Loop.
\end{enumerate}

\subsection{Main Processing Loop}

When the service enters the command processing loop, it waits until a message arrives to a service port, or a command is ready to be executed.\\
When an \textbf{STDFSS} command arrives on the \textbf{STDFSS\_PORT} port, the ofs will locate the device where the command is meant to be executed and it'll be added onto the device waiting queue, waiting for working process assignation. As commands arrive, the main loop will decide whether it can be executed concurrently with any other commands running on the same device, and in case the command can be executed, an entry will be created on the Idle Devices List waiting for it's execution.\\
Responses from Device Drivers and Standard Service commands will also be processed in the main loop.

\subsection{Waiting Device Command Queues}

Each device structure (\verb|struct sdevice_info|), has a field named \verb|waiting|. This list holds all commands waiting for execution on the device, plus a life time counter. Each time a working process finishes execution of a command, or a command arrives and there is a free working process, the service Main Loop, will check if the command can be executed. Conditions for command execution are:\\
\begin{enumerate}
\item[]- There are no commands being executed on the device.
\item[]- There are commands executing, but the command can be run concurrently.
\end{enumerate}

In order to decide whether the command can be run concurrently with processing commands this conditions must be met:

\begin{enumerate}
\item[]The command is not \textbf{UMOUNT}.
\item[]There are no \textbf{UMOUNT} commands on the waiting list, before the checking command.
\item[]Two commands for the same task, won`t run concurrently on the same device.
\item[]There are no commands in the waiting list with \verb|lifetime| on 0.
\end{enumerate}

Each time a command is selected for execution, every waiting command life time is decremented on 1 (unless it's already reached 0). This is used to prevent starvation on devices, due to concurrent command execution.

Once the Main thread has decided the command can be executed on the device, an entry is created at the end of the Idle Devices List and the waiting command is promoted to the top of the waiting list. 

\subsection{Working Threads Management}

Once every message has been processed, the Main Thread will attempt Idle Devices Commands execution. When a working process thread is detected to be idle, and there are commands ready to execute (i.e. the Idle Devices List is not empty), The first, free, working thread will be assigned to the first item on the Idle Devices List. Each of this items contain a Device ID, and a Logic Device ID. By using those Ids the Main Thread will get the device and start execution of the first command on the waiting list.\\
Working Threads won't be created unless they are needed. And once created they'll won't be destroyed unless there are too many unused threads.\\
As Idle Devices entries will be appended as commands come, or in case there's concurrent execution, starvation is prevented, each command is guarantied to be executed, and no device preference is made, meaning loaded devices will have as many chances to execute a command as a device with less commands waiting. 

\subsection{Response processing}

As it will be seen later, Working Processes have a signaling system. This system, allows a given thread to wait for a particular event. Most of the time, this events will be triggered by other services response messages.\\
The Main Thread will receive those messages and it'll check if a Working Process is waiting for it. If a WP is found, the signal will be raised and execution will continue. If no WP is found to be waiting for the message, the message will be discarded.

\section{Working Processes}

Working Processes, are threads in charge of command execution. Once the Main Thread decides a command is ready to begin execution, it'll assign it to a Working Process. There will be up to \verb|OFS_MAXWORKINGTHREADS| working processes running at the same time.\\
Each working process structure has the necessary fields in order to support node and devices locking, signaling and directory parsing.

\subsection{Nodes Locking}

Nodes locking is meant to provide a way to avoid two or more working processes from using the same nodes at the same time when processing commands. For example if a \verb|STDFSS_DELETE| command is being executed by one WP, and the other is starting an \verb|STDFSS_OPEN| command on the same file, if no locking was provided concurrent execution of these commands could lead to wrong or undesired behaviors.\\
Even though this will lock one of the working processes for a small period of time, this lockings allow concurrency.\\
The Service provides the means to lock up to Two nodes at the same time. One of the locks is sad to be a Node lock an the other a Directory Node Lock, although this naming is not quite accurate as both locks behave the same way.\\
When locking a node the working process will specify the node's ID, whether to use the directory lock or not, a lock mode and a failed status through the function \verb|lock_node|. If node locking is successful the function will return \verb|TRUE|, or false otherwise. If the node lock succeeded, the working process will free the lock by using the function \verb|unlock_node|, specifying if it`s unlocking the directory node or not, and giving an status value.

Lock modes defined are:

\begin{enumerate}
\item[]\textbf{OFS\_NODELOCK\_EXCLUSIVE} If specified, no other Working Process will be granted the Node lock while this working process has it. If there where other WP locking the node, the caller WP will be put to wait or the lock will fail, depending on whether \textbf{OFS\_NODELOCK\_BLOCKING} is specified.
\item[]\textbf{OFS\_NODELOCK\_BLOCKING} This mode, tells the locking function whether the lock should fail immediately, or it should wait until other locks are freed and return only if the lock cannot be acquired.
\item[]\textbf{OFS\_NODELOCK\_DIRECTORY} This mode tells the locking function to use the Directory Node Lock.
\end{enumerate}

When \verb|unlock_node| is called a status value must be passed as an argument. That status can be one of the following:

\begin{enumerate}
\item[]\textbf{OFS\_LOCKSTATUS\_OK} If this status is sent to \verb|unlock_node|, the node lock will be granted to waiting Working Processes. 
\item[]\textbf{OFS\_LOCKSTATUS\_DENY(a)} This statuses indicate Node lock should be denied (i.e Waiting WP will be refused the lock, by returning \verb|FALSE|) if the \verb|failed_status| parameter sent to \verb|lock_node| matches the \verb|unlock_node| status.
\item[]\textbf{OFS\_LOCKSTATUS\_DENYALL} Should this status be passed to \verb|unlock_node|, all waiting locks will be denied.
\end{enumerate}

As two node locks are maintained, and working Processes can be put to sleep until the given lock is available, special care had to be taken, for a deadlock might occur. \verb|lock_node| will verify there are no other working processes waiting for a lock we already have, and the node we are asking for is already locked. So far this has not been tested and might not work correctly.r. \verb|lock_node| will verify there are no other working processes waiting for a lock we already have, and the node we are asking for is already locked. So far this has not been tested and might not work correctly.

\subsection{Devices Locking}

As well as we need Node locking, in order for two WP not to collide, it can be seen device lockings are needed for mounting, unmounting, and file operations issued on devices. (i.e devices opened as files). Each working process will be able to lock up to one device.\footnote{Note when we speak about devices, we mean a serviceid/logicdeviceid pair, and not a single service id.}

Should a working process ask for a device lock taken by other process, it will be put to wait until the device lock is freed.

\subsection{Directory Parsing}

Directory parsing is performed by \verb|parse_directory|. This function is able to parse for a node by using it's path, and is also able to tell whether the supposed containing directory exists. As an extended feature if the \verb|flags| parameter is not a \verb|NULL| pointer and it's value is not \verb|0xFFFFFFFF|, flags will be changed if the node is found, on the containing directory to the ones specified.
If \verb|out_direntries| is not a \verb|NULL| pointer and the path refers to a directory file, the function will also calculate how many files it contains.

It's important to notice this function will ignore deleted files on directories.

If \verb|use_cache| is set to \verb|TRUE|, when first called this function will leave relevant information on the Working Process structure, in order to optimize a future call while processing the same command. Should this function be called using the cache for a given path, and then called with a different path, results of parsing will be unknown.

\section{Cached Devices}

The OFS service holds an avl structure for keeping devices being used by currently executing commands. This AVL Tree is also used to keep a certain amount of device which might be used by future commands. When a certain threshold is reached the service will attempt to free some devices, by removing those which are not opened as files, nor processing any commands or waiting for command execution. 
Each time a device executes a command, the device hit count is incremented, and once all other checks where performed the device with the lesser hits is removed, and freed.

\section{Mutexes And Locking Deadlocks}

Although Locking and mutexes has been look through many times, looking for possible deadlocks between Working Processes, the service has grown too much in size since I began programming it. I'll attempt to perform formal checks on lockings but until I'm quite sure there cannot be a deadlock, this will be an OPEN issue. 

\section{File Buffers}

When a read/write operation is issued on an opened file, and once check had been performed in order to validate the command, the working processes will attempt getting a file buffer for reading or writing data blocks from or to the device.
If the opened file already had a buffer, the WP will attempt to lock it, otherwise it'll get a buffer for the desired \verb|LBA| address.
Once the WP has the buffer it'll perform operations with it like preserve or fill and then it'll release the buffer.

Current File Buffer functions used on read or write, are:

\begin{enumerate}
\item[]\verb|fb_get|\\ This function will get a buffer for a given file info structure. The buffer lba address will be taken either using the <current node, current block> combination, or just current block, when it's a block device opened as a file. Character devices will not use file buffers. Parameter \verb|fill| indicates, upon return the buffer must contain current device (or buffered block) data loaded.\\
When this function is issued, the buffer assigned will be locked. If there were other buffer with a different lba address assigned before, which is being used by other opened files, the current buffer lock will be released.\\
This function \textbf{must} me called before a WP uses a file buffer, even if the current assigned filebuffer is non null and lba address is the same.\\
When a call to \verb|fb_get| is made, if the current file info lba address does not match with the one on the buffer, a new buffer will be granted.
\item[]\verb|fb_write|\\ This function provides the means to preserve buffer contents on the device. In order to call this function the buffer must have been acquired by issuing a call to \verb|fb_get|.
\item[]\verb|fb_finish| Once a working process has finished using a buffer, a call to this function mas be performed, in order to unlock the buffer.
\item[]\verb|fb_free| This function will release the opened file buffer, leaving it available for other opened files.
\end{enumerate}

All buffer operations MUST be performed using the file buffer functions.

Buffer sharing was one of the latest improvements performed on the OFS Service. Each device has an Avl Tree of buffers indexed by the buffer current LBA address. When a Working Process asks for a buffer for an opened file, that list will be checked and if a current buffer is found with the same \textbf{lba} address, that buffer will also be assigned to the requesting WP.

\subsection{Credits system}

As file buffers are a limited resource, an algorithm for assignation and removal had to be devised. The removal algorithm works by using the buffer hits and grace\_period values, together with the opened files references count.

These values will be assigned as follows:
\begin{enumerate}
\item[]\textbf{Hits} Each time a thread locks the buffer the hits count is incremented by 1
\item[]\textbf{Grace\_period} This value starts with a predefined value and is decremented on
each buffer removal candidate search.\\
\item[]\textbf{Opened files references} Each buffer, has a list indicating which opened files are using it.
\end{enumerate}

Credits are calculated by:

$C(b)=\left\{
\begin{array}
[c]{ll}%
b.hits\ast b.grace\_period\ast length(b.opened\_files)& \text{for }b.hits\text{ }\leq\text{ }max\_hits\\
0 & \text{for }b.hits\text{ }>\text{\ }max\_hits
\end{array}
\right.  $

The buffer with the lowest credit is a candidate for removal.

File Buffers available for the service \verb|MUST| be grater than Working Processes count, in order to ensure buffer assignation.

\section{Shared Nodes}

Being the latest addition to the ofs service, shared nodes provides the means to propagate file changes through opened files instantly, also saving memory resources. 
Say a file named \verb|my file.txt| has been opened twice, once for write/read and the other for read. What shared nodes do is, if the two opened files \verb|finf| structure is positioned at the same node, the pointer they have is exactly the same, so that changes performed on the node, affect both opened files.\\
In order to keep track of nodes, each \verb|dinf| structure holds a nodes AVL Tree. All nodes referenced by \verb|finf| structures or even on the working process threads are kept on that tree, indexed by its ID. When a node is referenced (i.e the pointer is assigned somewere) it has to be done by using the function \verb|nref|. In order to free a node reference \verb|nfree| must be issued.\\
Due to shared nodes referencing system, it's very important to read nodes from a device by using \verb|read_node| function, for it'll take care of node references.

\section{Node Buffers}

Current OFS node size is 128 bytes. This means on a 512 device block there will be up to four nodes. Node buffers are a way to speed up Node reading, by trying to re-use blocks already read. 
Each device structure will hold an amount of node buffers, and will reuse those buffers based on a hashing algorithm.
Functions \verb|read_node| and \verb|write_node| will make use of this buffers, and node read/write should be performed through these functions.

\section{Free Node Blocks Bitmaps}

Even though the best choice would have been to load Free Nodes/Blocks Bitmaps pieces while needed, currently the whole bitmaps are read, and kept on the \verb|mount_info| struct for a given device. Bitmaps preservations can be delayed in order to reduce device accessing time. Whether preservation is delayed or not will depend on how the files where opened or specific to each working process function.

\section{Notes}

The service has some sort of DOS protection. Denial Of Service protection is implemented by the following rules:
\begin{enumerate}
\item[]- Ports are read up to a maximum value and then processing continues
\item[]- Starvation is avoided on waiting algorithms, explained on the Main Thread section.
\end{enumerate}

As we don't have timeout capabilities (because there is no timer service or lib) if a device driver service fails while a thread is waiting for a MSG from it, the thread will deadlock. This can, and will be fixed with timeouts when we can implement an efficient timer lib or service.

This OFS Service implementation can handle only block devices with block size smaller than 4k and OFS\_BLOCKSIZE must be divisible by device block size. Although it hasn't been tested with a different device block size.

\end{document}
