#summary Creating Your OS on top of Sartoris Chapter 2: The boot Process

== What is the Boot Process? ==

We OS freaks (and mostly everyone) refer to the process of starting up a System as The _boot_ process. This process is made up of all the steps performed by the BIOS program and the Operating System in order to start the System.

Once the BIOS set's up most of the hardware and stuff, it will load the first 512 bytes from its selected boot media. Those bytes will be placed at a special location on physical memory and will be executed from the first position. That program is called _boot loader_ and will be in charge of loading the Operating System.

Sartoris takes care of loading itself by providing a two-stage boot loader which will locate the kernel on position 0 of memory and begin the microkernel initialization. Once it has loaded itself, sartoris will create a first [Tasks Task] called the Init Task, whose _id_ will be `INIT_TASK_NUM`, defined on `kernel.h`. 

== The Init Task == 

The Init Task, is the first task created on the system. Init Task memory will be initialized with the contents of the first megabyte next to the microkernel image on memory, and will be placed on a specific location on physical memory, defined by implementation. Sartoris will then create a [Threads Thread] for that Task with _id_ `INIT_THREAD_NUM`, whose entry point will be position 0 of the Init Task memory, and begin execution of that thread.

It's important to notice that once the init thread has been loaded Sartoris will assume a _Passive_ role, leaving execution to the OS (or real-time app) on top of it, and acting only through System Calls. 

When _Paging_ is enabled, the Init Task will be initially fully paged, up to the size specified by `INIT_SIZE` defined on the architecture dependant section of the Microkernel code.

== Boot Process Detailed (x86) ==

On the i386 implementation, Sartoris provides a two-stage boot loader which complies to the Multiboot specification. 

= The Bootloader =

=== Stage 1 ===

Sartoris boot sector code for the x86 architecture is defined on `arch/i386/boot/stage1.s`. 

This stage of the boot loader, will use BIOS functions to load boot loader _Stage 1.5_ code. It will verify the boot media and check for LBA. If LBA is supported, it will begin coping from possition defined on `stage2_sector` variable (currently 1 sector ahead) using int `0x13` function `0x45`, if LBA is not supported, it will translate the value to CHS using Drive Geometry obtained by function 0x8 of int `0x13` and use function `0x2` of the same interrupt to read from media.

Destination memory address for stage 1.5 is defined by `stage1_5seg16` on `arch/i386/boot/stages.inc`.

=== Stage 1.5 ===

This stage is only a a loader as the first one. It will use an encoded block-list to load _Stage 2_. 

When executed, Stage 1 will have left the following:

  * ds Pointing to `bootseg16`
  * ds:si = segment:offset of disk address packet/drive geometry
  * dl = Boot drive num
  * Stack Pointing to `0xEFFF - 0x4`

This stage will issue read commands to the boot device, using int `0x13` as it was done by Stage 1, but with the block list located at possition `0x187` from the beggining of the stage.

The encoded blocklist format will be:

|| Memory location || Name || Size || Default Value ||
|| `0x187` || `block_list_len` || `1 byte` || 1 ||
|| `0x188` || `block_list_start` || 6 * Block list nodes || Initial Node || 

Starting at `block_list_start` there will be a list of up to 20 nodes with the folloging structure:

{{{
struct list_node{
   int start,
   short length
}
}}}

By default Sartoris will complete the list with only one node, telling stage 1.5 loader to copy starting at lba 2 with a length of (7*128)+2 512 bytes blocks.

As the blocklist is located at a known possition on Sartoris image, this could be changed to point to a different _Stage 2_ Loader, even when the Microkernel is compiled.

= Sartoris Multiboot Loader =
