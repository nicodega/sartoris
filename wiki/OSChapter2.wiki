#summary Creating Your OS on top of Sartoris Chapter 2: The boot Process

== What is the Boot Process? ==

We OS freaks (and mostly everyone) refer to the process of starting up a System as The _boot_ process. This process is made up of all the steps performed by the BIOS program and the Operating System in order to start the System.

Once the BIOS set's up most of the hardware and stuff, it will load the first 512 bytes from its selected boot media. Those bytes will be placed at a special location on physical memory and will be executed from the first position. That program is called _boot loader_ and will be in charge of loading the Operating System.

Sartoris takes care of loading itself by providing a two-stage boot loader which will locate the kernel on position 0 of memory and begin the microkernel initialization. Once it has loaded itself, sartoris will create a first [Tasks Task] called the Init Task, whose _id_ will be `INIT_TASK_NUM`, defined on `kernel.h`. 

== The Init Task == 

The Init Task, is the first task created on the system. Init Task memory will be initialized with the contents of the first megabyte next to the microkernel image on memory, and will be placed on a specific location on physical memory, defined by implementation. Sartoris will then create a [Threads Thread] for that Task with _id_ `INIT_THREAD_NUM`, whose entry point will be position 0 of the Init Task memory, and begin execution of that thread.

It's important to notice that once the init thread has been loaded Sartoris will assume a _Passive_ role, leaving execution to the OS (or real-time app) on top of it, and acting only through System Calls. 

When _Paging_ is enabled, the Init Task will be initially fully paged, up to the size specified by `INIT_SIZE` defined on the architecture dependant section of the Microkernel code.

== Boot Process Detailed (x86) ==

On the i386 implementation, Sartoris provides a two-stage boot loader which complies to the Multiboot specification. 

= The Bootloader =

=== Stage 1 ===

Sartoris boot sector code for the x86 architecture is defined on `arch/i386/boot/stage1.s`. 

This stage of the boot loader, will use BIOS functions to load boot loader _Stage 1.5_ code. It will verify the boot media and check for LBA. If LBA is supported, it will begin coping from possition defined on `stage2_sector` variable (currently 1 sector ahead) using int `0x13` function `0x45`, if LBA is not supported, it will translate the value to CHS using Drive Geometry obtained by function 0x8 of int `0x13` and use function `0x2` of the same interrupt to read from media.

Destination memory address for stage 1.5 is defined by `stage1_5seg16` on `arch/i386/boot/stages.inc`.

=== Stage 1.5 ===

This stage is only a a loader as the first one. It will use an encoded block-list to load _Stage 2_. 

When executed, Stage 1 will have left the following:

  * ds Pointing to `bootseg16`
  * ds:si = segment:offset of disk address packet/drive geometry
  * dl = Boot drive num
  * Stack Pointing to `0xEFFF - 0x4`

This stage will issue read commands to the boot device, using int `0x13` as it was done by Stage 1, but with the block list located at possition `0x187` from the beggining of the stage.

The encoded blocklist format will be:

|| Memory location || Name || Size || Default Value ||
|| `0x187` || `block_list_len` || `1 byte` || 1 ||
|| `0x188` || `block_list_start` || `6 x Block list nodes` || Initial Node || 

Starting at `block_list_start` there will be a list of up to 20 nodes with the following structure:

{{{
struct list_node{
   int start,
   short length
}
}}}

By default Sartoris will complete the list with only one node, telling stage 1.5 loader to copy starting at lba 2 with a length of (7*128)+2 512 bytes blocks.

As the blocklist is located at a known possition on Sartoris image, this could be changed to point to a different _Stage 2_ Loader, even when the Microkernel is compiled.

Copy procedure destination on memory, will be taken from `nextstage_seg`, which is set to `stage2seg16:0x0000`.

It's important to notice, that until now, we have been running on 16 bit (real) mode.

=== Stage 2 ===

This stage is where most interesting things happen. Current Implementation is contained on `arch/i386/boot/stage2mem.s`.

When executed, Stage 1.5 will have left the following:

  * ds Pointing to `bootseg16`
  * ds:si = segment:offset of disk address packet/drive geometry
  * dl = Boot drive num
  * ax = Stage 2 image size

This stage will perform the following actions:

  * Check Multiboot header 
       As you will see on next section, starting at the end of
       Stage 2, is Sartoris Multiboot Header. Stage 2 will verify
       the multiboot magic number (`0x1BADB002`).
  * Enable A20
       You can google for this, but basically what it does here 
       is enable the A20 line on the processor, in order to 
       remove the 1MB limit set by the processor for backward
       compatibility with _really_ older systems.
  * Calculate Memory Size
       Memory size will be calculated using the BIOS interrupt `0x12` or 
       `0x15` function `0x88`.
       Here it will also ask the BIOS to provide a memory map issuing
       interrupt `0x15` Function `0xE820`.
  * Switch to Protected Mode
       In order to switch to protected mode the bootloader defines a GDT
       table and an LDT table.

       GDT table will have the following structure:

       || Dummy descriptor required by architecture || 0 ||
       || Code segment descriptor || limit=ffff base_adress=0 p-flag=1, dpl=0, s-flag=1 (non-system segment), type code exec/read g-flag=1, d/b bit=1 (limit mult by 4096, default 32-bit opsize), limit upper bits F ||
       || Data segment descriptor || limit=ffff, base_adress=0, p-flag=1, dpl=0, s-flag=1, type read/write, g-flag=1, d/b bit=1, limit upper bits F ||

      
  * Fill the Multiboot structure

Its important to notice Machine State left from this stage is conformig to Multiboot specification as defined [http://www.gnu.org/software/grub/manual/multiboot/html_node/Machine-state.html#Machine-state here].

= Sartoris Multiboot Loader =